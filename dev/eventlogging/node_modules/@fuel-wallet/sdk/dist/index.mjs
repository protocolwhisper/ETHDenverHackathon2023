import { InputType, Address, hexlify, transactionRequestify, WalletLocked, Provider, TransactionResponse } from 'fuels';
import EventEmitter from 'events';
import { JSONRPCClient, JSONRPCServer } from 'json-rpc-2.0';
import { v4 } from 'uuid';

// ../types/src/accounts.ts
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["contract"] = 0] = "contract";
  AddressType2[AddressType2["account"] = 1] = "account";
  return AddressType2;
})(AddressType || {});

// ../types/src/fuel.ts
var FuelWalletEvents = {
  accounts: "accounts",
  currentAccount: "currentAccount",
  connection: "connection",
  network: "network",
  assets: "assets"
};
var MessageTypes = /* @__PURE__ */ ((MessageTypes2) => {
  MessageTypes2["ping"] = "ping";
  MessageTypes2["uiEvent"] = "uiEvent";
  MessageTypes2["event"] = "event";
  MessageTypes2["request"] = "request";
  MessageTypes2["response"] = "response";
  MessageTypes2["removeConnection"] = "removeConnection";
  return MessageTypes2;
})(MessageTypes || {});

// ../types/src/constants.ts
var PAGE_SCRIPT_NAME = "Fuel";
var CONTENT_SCRIPT_NAME = "FuelContentScript";
var BACKGROUND_SCRIPT_NAME = "FuelBackgroundScript";
var POPUP_SCRIPT_NAME = "FuelPopUpScript";
var VAULT_SCRIPT_NAME = "FuelVaultScript";
var EVENT_MESSAGE = "message";

// src/config.ts
var MAX_EVENT_LISTENERS = 30;
var PING_TIMEOUT = 1e3;
var RECONNECT_TIMEOUT = 300;

// src/connections/BaseConnection.ts
var BaseConnection = class extends EventEmitter {
  constructor() {
    super();
    this.onCommunicationMessage = (message) => {
      switch (message.type) {
        case "response" /* response */:
          this.onResponse(message);
          break;
        case "request" /* request */:
          this.onRequest(message);
          break;
        case "event" /* event */:
          this.onEvent(message);
          break;
        case "uiEvent" /* uiEvent */:
          this.onUIEvent(message);
          break;
      }
    };
    this.setMaxListeners(MAX_EVENT_LISTENERS);
    this.client = new JSONRPCClient(this.sendRequest.bind(this));
    this.server = new JSONRPCServer();
  }
  externalMethods(methods) {
    methods.forEach((method) => {
      let methodName = method;
      if (method.name) {
        methodName = method.name;
      }
      this.server.addMethod(methodName, this[methodName].bind(this));
    });
  }
  async sendRequest(request) {
    throw new Error("Send request not implemented");
  }
  sendResponse(response, message) {
    throw new Error("Send response not implemented");
  }
  onEvent(message) {
    message.events.forEach((eventData) => {
      this.emit(eventData.event, ...eventData.params);
    });
  }
  onResponse(message) {
    this.client.receive(message.response);
  }
  onRequest(message) {
    this.server.receive(message.request).then((response) => {
      this.sendResponse(response, message);
    });
  }
  onUIEvent(message) {
  }
};

// src/connections/WindowConnection.ts
var WindowConnection = class extends BaseConnection {
  constructor() {
    super();
    this.onMessage = (message) => {
      const messageFroze = Object.freeze(message);
      if (!this.acceptMessage(messageFroze))
        return;
      const { data: event } = messageFroze;
      this.onCommunicationMessage(event);
    };
    window.addEventListener(EVENT_MESSAGE, this.onMessage.bind(this));
  }
  acceptMessage(message) {
    return true;
  }
  postMessage(message, origin) {
    window.postMessage(message, origin || window.origin);
  }
};
function getTransactionSigner(transaction) {
  const address = transaction.inputs?.map((i) => {
    switch (i.type) {
      case InputType.Message:
        return i.recipient;
      case InputType.Coin:
        return i.owner;
      default:
        return void 0;
    }
  })[0];
  if (!address) {
    throw new Error("No possible signer found!");
  }
  return Address.fromB256(hexlify(address)).toString();
}

// src/FuelWalletConnection.ts
var FuelWalletConnection = class extends WindowConnection {
  acceptMessage(message) {
    const { data: event } = message;
    return message.origin === window.origin && event.target === PAGE_SCRIPT_NAME;
  }
  async sendRequest(request) {
    if (request) {
      this.postMessage({
        type: "request" /* request */,
        target: CONTENT_SCRIPT_NAME,
        request
      });
    }
  }
  async ping() {
    return this.client.timeout(1e3).request("ping", {});
  }
  async network() {
    return this.client.request("network", {});
  }
  async isConnected() {
    return this.client.request("isConnected", {});
  }
  async connect() {
    return this.client.request("connect", {});
  }
  async disconnect() {
    return this.client.request("disconnect", {});
  }
  async accounts() {
    return this.client.request("accounts", {});
  }
  async currentAccount() {
    return this.client.request("currentAccount", {});
  }
  async signMessage(address, message) {
    if (!message.trim()) {
      throw new Error("Message is required");
    }
    return this.client.request("signMessage", {
      address,
      message
    });
  }
  async sendTransaction(transaction, providerConfig, signer) {
    if (!transaction) {
      throw new Error("Transaction is required");
    }
    const txRequest = transactionRequestify(transaction);
    const address = signer || transaction.signer || getTransactionSigner(txRequest);
    return this.client.request("sendTransaction", {
      address,
      provider: providerConfig,
      transaction: JSON.stringify(txRequest)
    });
  }
  async assets() {
    return this.client.request("assets", {});
  }
  async addAsset(asset) {
    return this.addAssets([asset]);
  }
  async addAssets(assets) {
    return this.client.request("addAssets", {
      assets
    });
  }
  on(eventName, listener) {
    return super.on(eventName, listener);
  }
};
var FuelWalletLocked = class extends WalletLocked {
  constructor(address, provider) {
    super(address, provider);
    this.provider = provider;
  }
  async signMessage(message) {
    return this.provider.walletConnection.signMessage(
      this.address.toString(),
      message
    );
  }
  async sendTransaction(transaction) {
    return this.provider.sendTransaction({
      ...transaction,
      signer: this.address.toString()
    });
  }
};
var FuelWalletProvider = class extends Provider {
  constructor(providerUrl, walletConnection) {
    super(providerUrl);
    this.walletConnection = walletConnection;
  }
  async sendTransaction(transactionRequestLike) {
    const transactionId = await this.walletConnection.sendTransaction(
      transactionRequestLike,
      { url: this.url }
    );
    const response = new TransactionResponse(transactionId, this);
    return response;
  }
};

// src/Fuel.ts
var FuelWeb3Privates = {};
var Fuel = class extends FuelWalletConnection {
  constructor() {
    super(...arguments);
    this.utils = {
      // TODO: remove createAddress once fuels-ts replace input
      // class address with string. The warn message is to avoid
      // developers to use this method.
      createAddress: (address) => {
        console.warn(
          "Do not use this method! It will be removed in the next release."
        );
        return Address.fromString(address);
      }
    };
    // Externalize events names
    this.events = FuelWalletEvents;
  }
  async getProvider() {
    const providerConfig = await this.network();
    if (FuelWeb3Privates.provider) {
      return FuelWeb3Privates.provider;
    }
    const provider = new FuelWalletProvider(providerConfig.url, this);
    FuelWeb3Privates.provider = provider;
    this.on(FuelWalletEvents.network, async (network) => {
      FuelWeb3Privates.provider?.connect(network.url);
    });
    return FuelWeb3Privates.provider;
  }
  async getWallet(address) {
    const provider = await this.getProvider();
    return new FuelWalletLocked(address, provider);
  }
};

// src/utils/blockExplorer.ts
var BLOCK_EXPLORER_URL = "https://fuellabs.github.io/block-explorer-v2/";
function getBlockExplorerLink({
  path,
  providerUrl
}) {
  return `${BLOCK_EXPLORER_URL}${path}${providerUrl ? `?providerUrl=${encodeURIComponent(providerUrl)}` : ""}`;
}

// src/utils/createReadOnly.ts
var createReadOnly = (fuel) => {
  return new Proxy(fuel, {
    get(target, prop) {
      return target[prop];
    },
    set(target, key, value) {
      if (Object.hasOwn(target, key) && ["_eventsCount", "_events"].includes(key)) {
        target[key] = value;
        return true;
      }
      return false;
    },
    defineProperty(target, key) {
      if (Object.hasOwn(target, key))
        return target[key];
      return false;
    },
    deleteProperty() {
      return false;
    }
  });
};
function createUUID() {
  return v4();
}

// src/utils/injectFuel.ts
function injectFuel(target) {
  const fuel = createReadOnly(new Fuel());
  Object.defineProperty(target, "fuel", {
    value: fuel,
    writable: false,
    enumerable: true,
    configurable: true
  });
  if (typeof document !== "undefined") {
    const fuelLoadedEvent = new CustomEvent("FuelLoaded", {
      detail: fuel
    });
    document.dispatchEvent(fuelLoadedEvent);
  }
}

// src/connections/ContentProxyConnection.ts
var ContentProxyConnection = class {
  constructor() {
    this.onDisconnect = () => {
      clearInterval(this._tryReconect);
      this._tryReconect = setInterval(() => {
        console.debug("[FUEL WALLET] reconnecting!");
        try {
          this.connection = this.connect();
          console.debug("[FUEL WALLET] reconnected!");
          clearInterval(this._tryReconect);
        } catch (err) {
          if (err.message === "Extension context invalidated.") {
            clearInterval(this._tryReconect);
            console.debug("[FUEL WALLET] context invalidated!");
          }
        }
      }, RECONNECT_TIMEOUT);
    };
    this.keepAlive = () => {
      try {
        this.connection.postMessage({
          target: BACKGROUND_SCRIPT_NAME,
          type: "ping" /* ping */
        });
        setTimeout(this.keepAlive, PING_TIMEOUT);
      } catch (err) {
        this.onDisconnect();
      }
    };
    this.onMessageFromExtension = (message) => {
      const shouldAcceptMessage = message.target === CONTENT_SCRIPT_NAME;
      if (shouldAcceptMessage) {
        this.postMessage(message);
      }
    };
    this.onMessageFromWindow = (message) => {
      const { data: event, origin } = Object.freeze(message);
      const shouldAcceptMessage = origin === window.location.origin && event.target === CONTENT_SCRIPT_NAME;
      if (shouldAcceptMessage) {
        this.connection.postMessage({
          ...event,
          target: BACKGROUND_SCRIPT_NAME
        });
      }
    };
    this.connection = this.connect();
    window.addEventListener(EVENT_MESSAGE, this.onMessageFromWindow);
    this.keepAlive();
  }
  connect() {
    const connection = chrome.runtime.connect(chrome.runtime.id, {
      name: BACKGROUND_SCRIPT_NAME
    });
    connection.onMessage.addListener(this.onMessageFromExtension);
    connection.onDisconnect.addListener(this.onDisconnect);
    return connection;
  }
  static start() {
    return new ContentProxyConnection();
  }
  postMessage(message) {
    const postMessage = {
      ...message,
      target: PAGE_SCRIPT_NAME
    };
    window.postMessage(postMessage, window.location.origin);
  }
};

// src/connections/ExtensionPageConnection.ts
var ExtensionPageConnection = class extends BaseConnection {
  constructor() {
    super();
    this.connection = chrome.runtime.connect(chrome.runtime.id, {
      name: BACKGROUND_SCRIPT_NAME
    });
    this.connection.onMessage.addListener(this.onCommunicationMessage);
    this.ready();
  }
  allowMessage(message) {
    return message.target === POPUP_SCRIPT_NAME;
  }
  sendResponse(response, message) {
    if (!response)
      return;
    const responseMessage = {
      id: message.id,
      target: BACKGROUND_SCRIPT_NAME,
      type: "response" /* response */,
      response
    };
    this.connection.postMessage(responseMessage);
    this.onResponseSent();
  }
  onResponseSent() {
    window.close();
  }
  ready() {
    const session = new URLSearchParams(window.location.search).get("s");
    this.connection.postMessage({
      target: BACKGROUND_SCRIPT_NAME,
      type: "uiEvent" /* uiEvent */,
      ready: true,
      session
    });
  }
  destroy() {
    this.connection.disconnect();
  }
};

export { AddressType, BACKGROUND_SCRIPT_NAME, BLOCK_EXPLORER_URL, BaseConnection, CONTENT_SCRIPT_NAME, ContentProxyConnection, EVENT_MESSAGE, ExtensionPageConnection, Fuel, FuelWalletConnection, FuelWalletEvents, FuelWalletLocked, FuelWalletProvider, MessageTypes, PAGE_SCRIPT_NAME, POPUP_SCRIPT_NAME, VAULT_SCRIPT_NAME, WindowConnection, createReadOnly, createUUID, getBlockExplorerLink, getTransactionSigner, injectFuel };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map