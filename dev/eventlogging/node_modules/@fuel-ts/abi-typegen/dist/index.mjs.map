{"version":3,"sources":["../src/AbiTypeGen.ts","../src/templates/utils/renderHbsTemplate.ts","../src/templates/contract/dts.ts","../src/templates/contract/factory.ts","../src/utils/normalize.ts","../src/utils/findType.ts","../src/utils/parseTypeArguments.ts","../src/functions/Function.ts","../src/utils/makeFunction.ts","../src/utils/parseFunctions.ts","../src/types/AType.ts","../src/types/ArrayType.ts","../src/types/StrType.ts","../src/types/B256Type.ts","../src/types/B512Type.ts","../src/types/BoolType.ts","../src/utils/extractStructName.ts","../src/types/EnumType.ts","../src/types/GenericType.ts","../src/types/OptionType.ts","../src/types/U8Type.ts","../src/types/U64Type.ts","../src/types/RawUntypedPtr.ts","../src/types/StructType.ts","../src/types/TupleType.ts","../src/types/U16Type.ts","../src/types/U32Type.ts","../src/types/VectorType.ts","../src/utils/supportedTypes.ts","../src/utils/makeType.ts","../src/utils/shouldSkipAbiType.ts","../src/utils/parseTypes.ts","../src/Abi.ts","../src/templates/common/common.ts","../src/templates/contract/index.ts"],"sourcesContent":["import { join } from 'path';\n\nimport { Abi } from './Abi';\nimport type { IFile } from './interfaces/IFile';\nimport { renderCommonTemplate } from './templates/common/common';\nimport { renderIndexTemplate } from './templates/contract/index';\n\n/*\n  Manages many instances of Abi\n*/\nexport class AbiTypeGen {\n  public readonly abis: Abi[];\n  public readonly abiFiles: IFile[];\n  public readonly outputDir: string;\n\n  public readonly files: IFile[];\n\n  constructor(params: { abiFiles: IFile[]; outputDir: string }) {\n    const { abiFiles, outputDir } = params;\n\n    this.files = [];\n    this.outputDir = outputDir;\n    this.abiFiles = abiFiles;\n\n    // Creates a `Abi` for each abi file\n    this.abis = this.abiFiles.map((abiFile) => {\n      const abi = new Abi({\n        filepath: abiFile.path,\n        rawContents: JSON.parse(abiFile.contents),\n        outputDir,\n      });\n      return abi;\n    });\n\n    // Assemble list of files to be written to disk\n    this.assembleAllFiles();\n  }\n\n  private assembleAllFiles() {\n    const usesCommonTypes = this.abis.find((a) => a.commonTypesInUse.length > 0);\n\n    // Assemble all DTS and Factory typescript files\n    this.abis.forEach((abi) => {\n      const dts: IFile = {\n        path: abi.dtsFilepath,\n        contents: abi.getDtsDeclaration(),\n      };\n\n      const factory: IFile = {\n        path: abi.factoryFilepath,\n        contents: abi.getFactoryDeclaration(),\n      };\n\n      this.files.push(dts);\n      this.files.push(factory);\n    });\n\n    // Includes index file\n    const indexFile: IFile = {\n      path: `${this.outputDir}/index.ts`,\n      contents: renderIndexTemplate({ abis: this.abis }),\n    };\n\n    this.files.push(indexFile);\n\n    // Conditionally includes `common.d.ts` file if needed\n    if (usesCommonTypes) {\n      const commonsFilepath = join(this.outputDir, 'common.d.ts');\n      const file: IFile = {\n        path: commonsFilepath,\n        contents: renderCommonTemplate(),\n      };\n      this.files.push(file);\n    }\n  }\n}\n","import { versions } from '@fuel-ts/versions';\nimport { compile } from 'handlebars';\n\nimport headerTemplate from '../common/_header.hbs';\n\n/*\n  Renders the given template w/ the given data, while injecting common\n  header for disabling lint rules and annotating Fuel component's versions.\n*/\nexport function renderHbsTemplate(params: { template: string; data?: Record<string, unknown> }) {\n  const { data, template } = params;\n\n  const options = {\n    strict: true,\n    noEscape: true,\n  };\n\n  const renderTemplate = compile(template, options);\n  const renderHeaderTemplate = compile(headerTemplate, options);\n\n  const text = renderTemplate({\n    ...data,\n    header: renderHeaderTemplate(versions),\n  });\n\n  return text.replace(/[\\n]{3,}/gm, '\\n\\n');\n}\n","import type { Abi } from '../../Abi';\nimport { TargetEnum } from '../../interfaces/TargetEnum';\nimport type { EnumType } from '../../types/EnumType';\nimport type { StructType } from '../../types/StructType';\nimport { renderHbsTemplate } from '../utils/renderHbsTemplate';\n\nimport dtsTemplate from './dts.hbs';\n\nexport function renderDtsTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, types, functions, commonTypesInUse } = params.abi;\n\n  /*\n    First we format all attributes\n  */\n  const functionsTypedefs = functions.map((f) => f.getDeclaration());\n\n  const functionsFragments = functions.map((f) => f.attributes.name);\n\n  const encoders = functions.map((f) => ({\n    functionName: f.attributes.name,\n    input: f.attributes.inputs,\n  }));\n\n  const decoders = functions.map((f) => ({\n    functionName: f.attributes.name,\n  }));\n\n  const structs = types\n    .filter((t) => t.name === 'struct')\n    .map((t) => {\n      const st = t as StructType; // only structs here\n      const structName = st.getStructName();\n      const inputValues = st.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = st.getStructContents({ types, target: TargetEnum.OUTPUT });\n      const typeAnnotations = st.getStructDeclaration({ types });\n      return {\n        structName,\n        typeAnnotations,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n      };\n    });\n\n  const enums = types\n    .filter((t) => t.name === 'enum')\n    .map((t) => {\n      const et = t as EnumType; // only enums here\n      const structName = et.getStructName();\n      const inputValues = et.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = et.getStructContents({ types, target: TargetEnum.OUTPUT });\n      return {\n        structName,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n      };\n    });\n\n  /*\n    And finally render template\n  */\n  const text = renderHbsTemplate({\n    template: dtsTemplate,\n    data: {\n      capitalizedName,\n      commonTypesInUse: commonTypesInUse.join(', '),\n      functionsTypedefs,\n      functionsFragments,\n      encoders,\n      decoders,\n      structs,\n      enums,\n    },\n  });\n\n  return text;\n}\n","import type { Abi } from '../../Abi';\nimport { renderHbsTemplate } from '../utils/renderHbsTemplate';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, rawContents } = params.abi;\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: { capitalizedName, abiJsonString },\n  });\n\n  return text;\n}\n","import upperFirst from 'lodash.upperfirst';\n\n/**\n * Converts valid file names to valid javascript symbols and does\n * best effort to make them readable.\n *\n * Example: ds-token.test becomes DsTokenTest\n */\nexport function normalizeName(rawName: string): string {\n  const transformations: ((s: string) => string)[] = [\n    (s) => s.replace(/\\s+/g, '-'), // spaces to -\n    (s) => s.replace(/\\./g, '-'), // dots to -\n    (s) => s.replace(/_/g, '-'), // underscore to -\n    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()), // delete '-' and capitalize the letter after them\n    (s) => s.replace(/-/g, ''), // delete any '-' left\n    (s) => s.replace(/^\\d+/, ''), // removes leading digits\n    (s) => upperFirst(s),\n  ];\n\n  const finalName = transformations.reduce((s, t) => t(s), rawName);\n\n  if (finalName === '') {\n    throw new Error(`Can't guess class name, please rename file: ${rawName}`);\n  }\n\n  return finalName;\n}\n","import type { IType } from '../interfaces/IType';\n\nexport function findType(params: { types: IType[]; typeId: number }) {\n  const { types, typeId } = params;\n\n  const foundType = types.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);\n\n  if (!foundType) {\n    throw new Error(`Type ID not found: ${typeId}.`);\n  }\n\n  // ensure type attributes is always parsed\n  foundType.parseComponentsAttributes({ types });\n\n  return foundType;\n}\n","import type { IRawAbiTypeComponent } from '../interfaces/IRawAbiType';\nimport type { IType } from '../interfaces/IType';\nimport type { TargetEnum } from '../interfaces/TargetEnum';\n\nimport { findType } from './findType';\n\n/*\n  Recursively parses the given `typeArguments` node\n*/\nexport function parseTypeArguments(params: {\n  types: IType[];\n  target: TargetEnum;\n  typeArguments: IRawAbiTypeComponent[];\n  parentTypeId?: number;\n}): string {\n  const { types, typeArguments, parentTypeId, target } = params;\n\n  const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n  const buffer: string[] = [];\n\n  let parentType: IType | undefined;\n  let parentLabel: string | undefined;\n\n  if (parentTypeId !== undefined) {\n    parentType = findType({ types, typeId: parentTypeId });\n    parentLabel = parentType.attributes[attributeKey];\n  }\n\n  // loop through all `typeArgument` items\n  typeArguments.forEach((typeArgument) => {\n    let currentLabel: string;\n\n    const currentTypeId = typeArgument.type;\n\n    try {\n      const currentType = findType({ types, typeId: currentTypeId });\n      currentLabel = currentType.attributes[attributeKey];\n    } catch (_err) {\n      // used for functions without output\n      currentLabel = 'void';\n    }\n\n    if (typeArgument.typeArguments) {\n      // recursively process nested `typeArguments`\n      const nestedParsed = parseTypeArguments({\n        types,\n        target,\n        parentTypeId: typeArgument.type,\n        typeArguments: typeArgument.typeArguments,\n      });\n\n      buffer.push(nestedParsed);\n    } else {\n      buffer.push(`${currentLabel}`);\n    }\n  });\n\n  let output = buffer.join(', ');\n\n  if (parentLabel) {\n    output = `${parentLabel}<${output}>`;\n  }\n\n  return output;\n}\n","import type { IFunction, IFunctionAttributes } from '../interfaces/IFunction';\nimport type { IRawAbiFunction } from '../interfaces/IRawAbiFunction';\nimport type { IType } from '../interfaces/IType';\nimport { TargetEnum } from '../interfaces/TargetEnum';\nimport { findType } from '../utils/findType';\nimport { parseTypeArguments } from '../utils/parseTypeArguments';\n\nexport class Function implements IFunction {\n  public types: IType[];\n  public rawAbiFunction: IRawAbiFunction;\n  public attributes: IFunctionAttributes;\n\n  constructor(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n    this.types = params.types;\n    this.rawAbiFunction = params.rawAbiFunction;\n\n    this.attributes = {\n      name: this.rawAbiFunction.name,\n      inputs: this.bundleInputTypes(),\n      output: this.bundleOutputTypes(),\n      prefixedInputs: this.bundleInputTypes(true),\n    };\n  }\n\n  bundleInputTypes(shouldPrefixParams: boolean = false) {\n    const { types } = this;\n\n    // loop through all inputs\n    const inputs = this.rawAbiFunction.inputs.map((input) => {\n      const { name, type: typeId, typeArguments } = input;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target: TargetEnum.INPUT,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        typeDecl = type.attributes.inputLabel;\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      if (shouldPrefixParams) {\n        return `${name}: ${typeDecl}`;\n      }\n\n      return typeDecl;\n    });\n\n    return inputs.join(', ');\n  }\n\n  bundleOutputTypes() {\n    return parseTypeArguments({\n      types: this.types,\n      target: TargetEnum.OUTPUT,\n      typeArguments: [this.rawAbiFunction.output],\n    });\n  }\n\n  getDeclaration() {\n    const { name, prefixedInputs, output } = this.attributes;\n    const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output}>`;\n    return decl;\n  }\n}\n","import { Function } from '../functions/Function';\nimport type { IRawAbiFunction } from '../interfaces/IRawAbiFunction';\nimport type { IType } from '../interfaces/IType';\n\nexport function makeFunction(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n  const { types, rawAbiFunction } = params;\n  return new Function({ types, rawAbiFunction });\n}\n","import type { IFunction } from '../interfaces/IFunction';\nimport type { IRawAbiFunction } from '../interfaces/IRawAbiFunction';\nimport type { IType } from '../interfaces/IType';\n\nimport { makeFunction } from './makeFunction';\n\nexport function parseFunctions(params: { types: IType[]; rawAbiFunctions: IRawAbiFunction[] }) {\n  const { types, rawAbiFunctions } = params;\n  const functions: IFunction[] = rawAbiFunctions.map((rawAbiFunction) =>\n    makeFunction({ types, rawAbiFunction })\n  );\n  return functions;\n}\n","import type { IRawAbiTypeRoot } from '../interfaces/IRawAbiType';\nimport type { ITypeAttributes } from '../interfaces/IType';\n\nexport class AType {\n  public rawAbiType: IRawAbiTypeRoot;\n  public attributes: ITypeAttributes;\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    this.rawAbiType = params.rawAbiType;\n    this.attributes = {\n      inputLabel: 'unknown',\n      outputLabel: 'unknown',\n    };\n  }\n}\n","import type { IType } from '../interfaces/IType';\nimport { TargetEnum } from '../interfaces/TargetEnum';\nimport { findType } from '../utils/findType';\nimport { parseTypeArguments } from '../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class ArrayType extends AType implements IType {\n  // Note: the array length expressed in '; 2]' could be any length\n  public static swayType = '[_; 2]';\n\n  public name = 'array';\n\n  static MATCH_REGEX: RegExp = /^\\[_; ([0-9]+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return ArrayType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n    const { type } = this.rawAbiType;\n\n    // array length will be used to generated a fixed-length array type\n    const arrayLen = Number(type.match(ArrayType.MATCH_REGEX)?.[1]);\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilà\n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    // fixed-length array, based on `arrayLen`\n    const inputTypes = Array(arrayLen).fill(inputs[0]).join(', ');\n    const outputTypes = Array(arrayLen).fill(outputs[0]).join(', ');\n\n    this.attributes = {\n      inputLabel: `[${inputTypes}]`,\n      outputLabel: `[${outputTypes}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class StrType extends AType implements IType {\n  // Note: the str length expressed in '[3]' could be any length\n  public static swayType = 'str[3]';\n\n  public name = 'str';\n\n  static MATCH_REGEX: RegExp = /^str\\[(.+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return StrType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'string',\n      outputLabel: 'string',\n    };\n    return this.attributes;\n  }\n}\n","import { StrType } from './StrType';\n\nexport class B256Type extends StrType {\n  public static swayType = 'b256';\n\n  public name = 'b256';\n\n  static MATCH_REGEX = /^b256$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B256Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import { B256Type } from './B256Type';\n\nexport class B512Type extends B256Type {\n  public static swayType = 'b512';\n\n  public name = 'b512';\n\n  static MATCH_REGEX = /^b512$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B512Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class BoolType extends AType implements IType {\n  public static swayType = 'bool';\n\n  public name = 'bool';\n\n  static MATCH_REGEX: RegExp = /^bool$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return BoolType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'boolean',\n      outputLabel: 'boolean',\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeRoot } from '../interfaces/IRawAbiType';\n\nexport function extractStructName(params: { rawAbiType: IRawAbiTypeRoot; regex: RegExp }) {\n  const { rawAbiType, regex } = params;\n\n  const match = rawAbiType.type.match(params.regex)?.[1];\n\n  if (!match) {\n    let errorMessage = `Couldn't extract struct name with: '${regex}'.\\n\\n`;\n    errorMessage += `Check your JSON ABI.\\n\\n[source]\\n`;\n    errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;\n\n    throw new Error(errorMessage);\n  }\n\n  return match;\n}\n","import type { IRawAbiTypeComponent } from '../interfaces/IRawAbiType';\nimport type { IType } from '../interfaces/IType';\nimport type { TargetEnum } from '../interfaces/TargetEnum';\nimport { extractStructName } from '../utils/extractStructName';\nimport { findType } from '../utils/findType';\n\nimport { AType } from './AType';\n\nexport class EnumType extends AType implements IType {\n  public static swayType = 'enum MyEnumName';\n\n  public name = 'enum';\n\n  static MATCH_REGEX: RegExp = /^enum (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = EnumType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = EnumType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: EnumType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const enumComponents = components as IRawAbiTypeComponent[];\n\n    const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n    const contents = enumComponents.map((component) => {\n      const { name, type: typeId } = component;\n\n      if (typeId === 0) {\n        return `${name}: []`;\n      }\n\n      const { attributes } = findType({ types, typeId });\n      return `${name}: ${attributes[attributeKey]}`;\n    });\n\n    return contents.join(', ');\n  }\n}\n","import type { IType } from '../interfaces/IType';\nimport { extractStructName } from '../utils/extractStructName';\n\nimport { AType } from './AType';\n\nexport class GenericType extends AType implements IType {\n  public static swayType = 'generic T';\n\n  public name = 'generic';\n\n  static MATCH_REGEX: RegExp = /^generic ([^\\s]+)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return GenericType.MATCH_REGEX.test(params.type);\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: GenericType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const label = this.getStructName();\n\n    this.attributes = {\n      inputLabel: label,\n      outputLabel: label,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class OptionType extends AType implements IType {\n  public static swayType = 'enum Option';\n\n  public name = 'option';\n\n  static MATCH_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return OptionType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Option`,\n      outputLabel: `Option`,\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeRoot } from '../interfaces/IRawAbiType';\nimport type { IType } from '../interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class U8Type extends AType implements IType {\n  public static swayType = 'u8';\n\n  public name = 'u8';\n\n  public static MATCH_REGEX: RegExp = /^u8$/m;\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    super(params);\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `number`,\n    };\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U8Type.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    return this.attributes;\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U64Type extends U8Type implements IType {\n  public static swayType = 'u64';\n\n  public name = 'u64';\n\n  public static MATCH_REGEX: RegExp = /^u64$/m;\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `BN`,\n    };\n    return this.attributes;\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U64Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { U64Type } from './U64Type';\n\nexport class RawUntypedPtr extends U64Type implements IType {\n  public static swayType = 'raw untyped ptr';\n\n  public name = 'rawUntypedPtr';\n\n  public static MATCH_REGEX: RegExp = /^raw untyped ptr$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return RawUntypedPtr.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IRawAbiTypeComponent } from '../interfaces/IRawAbiType';\nimport type { IType } from '../interfaces/IType';\nimport type { TargetEnum } from '../interfaces/TargetEnum';\nimport { extractStructName } from '../utils/extractStructName';\nimport { findType } from '../utils/findType';\nimport { parseTypeArguments } from '../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class StructType extends AType implements IType {\n  public static swayType = 'struct MyStruct';\n\n  public name = 'struct';\n\n  static MATCH_REGEX: RegExp = /^struct (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^struct (Vec|RawVec)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = StructType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = StructType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: StructType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const structComponents = components as IRawAbiTypeComponent[];\n\n    // loop through all components\n    const members = structComponents.map((component) => {\n      const { name, type: typeId, typeArguments } = component;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n        typeDecl = type.attributes[attributeKey];\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      return `${name}: ${typeDecl}`;\n    });\n\n    return members.join(', ');\n  }\n\n  public getStructDeclaration(params: { types: IType[] }) {\n    const { types } = params;\n    const { typeParameters } = this.rawAbiType;\n\n    if (typeParameters) {\n      const structs = typeParameters.map((typeId) => findType({ types, typeId }));\n\n      const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);\n\n      return `<${labels.join(', ')}>`;\n    }\n\n    return '';\n  }\n}\n","import type { IType } from '../interfaces/IType';\nimport { TargetEnum } from '../interfaces/TargetEnum';\nimport { findType } from '../utils/findType';\nimport { parseTypeArguments } from '../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class TupleType extends AType implements IType {\n  // Note: a tuple can have more/less than 3x items (like the one bellow)\n  public static swayType = '(_, _, _)';\n\n  public name = 'tupple';\n\n  static MATCH_REGEX: RegExp = /^\\([_,\\s]+\\)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return TupleType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilà\n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    this.attributes = {\n      inputLabel: `[${inputs.join(', ')}]`,\n      outputLabel: `[${outputs.join(', ')}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U16Type extends U8Type implements IType {\n  public static swayType = 'u16';\n\n  public name = 'u16';\n\n  public static MATCH_REGEX: RegExp = /^u16$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U16Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U32Type extends U8Type implements IType {\n  public static swayType = 'u32';\n\n  public name = 'u32';\n\n  public static MATCH_REGEX: RegExp = /^u32$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U32Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../interfaces/IType';\n\nimport { ArrayType } from './ArrayType';\n\nexport class VectorType extends ArrayType {\n  public static swayType = 'struct Vec';\n\n  public name = 'vector';\n\n  static MATCH_REGEX: RegExp = /^struct Vec/m;\n  static IGNORE_REGEX: RegExp = /^struct RawVec$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = VectorType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = VectorType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Vec`,\n      outputLabel: `Vec`,\n    };\n    return this.attributes;\n  }\n}\n","import { ArrayType } from '../types/ArrayType';\nimport { B256Type } from '../types/B256Type';\nimport { B512Type } from '../types/B512Type';\nimport { BoolType } from '../types/BoolType';\nimport { EnumType } from '../types/EnumType';\nimport { GenericType } from '../types/GenericType';\nimport { OptionType } from '../types/OptionType';\nimport { RawUntypedPtr } from '../types/RawUntypedPtr';\nimport { StrType } from '../types/StrType';\nimport { StructType } from '../types/StructType';\nimport { TupleType } from '../types/TupleType';\nimport { U16Type } from '../types/U16Type';\nimport { U32Type } from '../types/U32Type';\nimport { U64Type } from '../types/U64Type';\nimport { U8Type } from '../types/U8Type';\nimport { VectorType } from '../types/VectorType';\n\nexport const supportedTypes = [\n  ArrayType,\n  B256Type,\n  B512Type,\n  BoolType,\n  EnumType,\n  GenericType,\n  OptionType,\n  RawUntypedPtr,\n  StrType,\n  StructType,\n  TupleType,\n  U16Type,\n  U32Type,\n  U64Type,\n  U8Type,\n  VectorType,\n];\n","import type { IRawAbiTypeRoot } from '../interfaces/IRawAbiType';\n\nimport { supportedTypes } from './supportedTypes';\n\nexport function makeType(params: { rawAbiType: IRawAbiTypeRoot }) {\n  const { rawAbiType } = params;\n  const { type } = rawAbiType;\n\n  const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type }));\n\n  if (!TypeClass) {\n    throw new Error(`Type not supported: ${type}`);\n  }\n\n  return new TypeClass(params);\n}\n","export function shouldSkipAbiType(params: { type: string }) {\n  const ignoreList = ['()', 'struct RawVec'];\n  const shouldSkip = ignoreList.indexOf(params.type) >= 0;\n  return shouldSkip;\n}\n","import type { IRawAbiTypeRoot } from '../interfaces/IRawAbiType';\nimport type { IType } from '../interfaces/IType';\n\nimport { makeType } from './makeType';\nimport { shouldSkipAbiType } from './shouldSkipAbiType';\n\nexport function parseTypes(params: { rawAbiTypes: IRawAbiTypeRoot[] }) {\n  const types: IType[] = [];\n\n  // First we parse all ROOT nodes\n  params.rawAbiTypes.forEach((rawAbiType) => {\n    const { type } = rawAbiType;\n    const skip = shouldSkipAbiType({ type });\n    if (!skip) {\n      const parsedType = makeType({ rawAbiType });\n      types.push(parsedType);\n    }\n  });\n\n  // Then we parse all thei r components' [attributes]\n  types.forEach((type) => {\n    type.parseComponentsAttributes({ types });\n  });\n\n  return types;\n}\n","import type { IFunction } from './interfaces/IFunction';\nimport type { IRawAbi } from './interfaces/IRawAbi';\nimport type { IType } from './interfaces/IType';\nimport { renderDtsTemplate } from './templates/contract/dts';\nimport { renderFactoryTemplate } from './templates/contract/factory';\nimport { normalizeName } from './utils/normalize';\nimport { parseFunctions } from './utils/parseFunctions';\nimport { parseTypes } from './utils/parseTypes';\n\n/*\n  Manages many instances of Types and Functions\n*/\nexport class Abi {\n  public name: string;\n  public filepath: string;\n  public outputDir: string;\n\n  public dtsFilepath: string;\n  public factoryFilepath: string;\n\n  public commonTypesInUse: string[] = [];\n\n  public rawContents: IRawAbi;\n  public types: IType[];\n  public functions: IFunction[];\n\n  constructor(params: { filepath: string; outputDir: string; rawContents: IRawAbi }) {\n    const { filepath, outputDir, rawContents } = params;\n\n    // processing abi name\n    const abiNameRegex = /([^/]+)-abi\\.json$/m;\n    const abiName = filepath.match(abiNameRegex);\n\n    if (!abiName || abiName.length === 0) {\n      throw new Error(`Could not parse name from abi file: ${filepath}`);\n    }\n\n    const name = `${normalizeName(abiName[1])}Abi`;\n\n    // processing output filepaths\n    this.dtsFilepath = `${outputDir}/${name}.d.ts`;\n    this.factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    // saving properties to class scope\n    this.name = name;\n    this.filepath = filepath;\n    this.rawContents = rawContents;\n    this.outputDir = outputDir;\n\n    const { types, functions } = this.parse();\n\n    this.types = types;\n    this.functions = functions;\n    this.computeCommonTypesInUse();\n  }\n\n  parse() {\n    const { types: rawAbiTypes, functions: rawAbiFunctions } = this.rawContents;\n\n    const types = parseTypes({ rawAbiTypes });\n    const functions = parseFunctions({ rawAbiFunctions, types });\n\n    return {\n      types,\n      functions,\n    };\n  }\n\n  getDtsDeclaration() {\n    return renderDtsTemplate({ abi: this });\n  }\n\n  getFactoryDeclaration() {\n    return renderFactoryTemplate({ abi: this });\n  }\n\n  computeCommonTypesInUse() {\n    const customTypesTable: Record<string, string> = {\n      option: 'Option',\n      enum: 'Enum',\n      vector: 'Vec',\n    };\n\n    this.commonTypesInUse = [];\n\n    Object.keys(customTypesTable).forEach((typeName) => {\n      const isInUse = !!this.types.find((t) => t.name === typeName);\n\n      if (isInUse) {\n        const commonTypeLabel: string = customTypesTable[typeName];\n        this.commonTypesInUse.push(commonTypeLabel);\n      }\n    });\n  }\n}\n","import { renderHbsTemplate } from '../utils/renderHbsTemplate';\n\nimport commonTemplate from './common.hbs';\n\nexport function renderCommonTemplate() {\n  const text = renderHbsTemplate({ template: commonTemplate });\n  return text;\n}\n","import type { Abi } from '../../Abi';\nimport { renderHbsTemplate } from '../utils/renderHbsTemplate';\n\nimport indexTemplate from './index.hbs';\n\nexport function renderIndexTemplate(params: { abis: Abi[] }) {\n  const abiCapitalizedNames = params.abis.map(({ name }) => name);\n\n  const text = renderHbsTemplate({\n    template: indexTemplate,\n    data: { abiCapitalizedNames },\n  });\n\n  return text;\n}\n"],"mappings":"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","names":["join","versions","compile","renderHbsTemplate","params","data","template","options","renderTemplate","compile","renderHeaderTemplate","header_default","versions","renderDtsTemplate","params","capitalizedName","types","functions","commonTypesInUse","functionsTypedefs","f","functionsFragments","encoders","decoders","structs","t","st","structName","inputValues","outputValues","typeAnnotations","enums","et","renderHbsTemplate","dts_default","renderFactoryTemplate","params","capitalizedName","rawContents","abiJsonString","renderHbsTemplate","factory_default","upperFirst","normalizeName","rawName","finalName","s","match","t","findType","params","types","typeId","foundType","tid","parseTypeArguments","params","types","typeArguments","parentTypeId","target","attributeKey","buffer","parentType","parentLabel","findType","typeArgument","currentLabel","currentTypeId","nestedParsed","output","Function","params","shouldPrefixParams","types","input","name","typeId","typeArguments","type","findType","typeDecl","parseTypeArguments","prefixedInputs","output","makeFunction","params","types","rawAbiFunction","Function","parseFunctions","params","types","rawAbiFunctions","rawAbiFunction","makeFunction","AType","params","_ArrayType","AType","params","_a","_b","types","type","arrayLen","inputs","outputs","component","typeId","typeArguments","inputLabel","parseTypeArguments","outputLabel","attributes","findType","inputTypes","outputTypes","ArrayType","_StrType","AType","params","_params","StrType","_B256Type","StrType","params","B256Type","_B512Type","B256Type","params","B512Type","_BoolType","AType","params","_params","BoolType","extractStructName","params","_a","rawAbiType","regex","match","errorMessage","_EnumType","AType","params","isAMatch","shouldBeIgnored","_params","structName","extractStructName","types","target","components","enumComponents","attributeKey","component","name","typeId","attributes","findType","EnumType","_GenericType","AType","params","extractStructName","_params","label","GenericType","_OptionType","AType","params","_params","OptionType","_U8Type","AType","params","_params","U8Type","_U64Type","U8Type","_params","params","U64Type","_RawUntypedPtr","U64Type","params","RawUntypedPtr","_StructType","AType","params","isAMatch","shouldBeIgnored","_params","structName","extractStructName","types","target","components","component","name","typeId","typeArguments","type","findType","typeDecl","parseTypeArguments","attributeKey","typeParameters","inputLabel","StructType","_TupleType","AType","params","_a","types","inputs","outputs","component","typeId","typeArguments","inputLabel","parseTypeArguments","outputLabel","attributes","findType","TupleType","_U16Type","U8Type","params","U16Type","_U32Type","U8Type","params","U32Type","_VectorType","ArrayType","params","isAMatch","shouldBeIgnored","_params","VectorType","supportedTypes","ArrayType","B256Type","B512Type","BoolType","EnumType","GenericType","OptionType","RawUntypedPtr","StrType","StructType","TupleType","U16Type","U32Type","U64Type","U8Type","VectorType","makeType","params","rawAbiType","type","TypeClass","supportedTypes","tc","shouldSkipAbiType","params","parseTypes","params","types","rawAbiType","type","shouldSkipAbiType","parsedType","makeType","Abi","params","filepath","outputDir","rawContents","abiNameRegex","abiName","name","normalizeName","types","functions","rawAbiTypes","rawAbiFunctions","parseTypes","parseFunctions","renderDtsTemplate","renderFactoryTemplate","customTypesTable","typeName","t","commonTypeLabel","renderCommonTemplate","renderHbsTemplate","common_default","renderIndexTemplate","params","abiCapitalizedNames","name","renderHbsTemplate","contract_default","AbiTypeGen","params","abiFiles","outputDir","abiFile","Abi","usesCommonTypes","a","abi","dts","factory","indexFile","renderIndexTemplate","file","join","renderCommonTemplate"]}