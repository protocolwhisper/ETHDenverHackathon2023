import{join as St}from"path";import{versions as xt}from"@fuel-ts/versions";import{compile as pt}from"handlebars";var nt=`/* Autogenerated file. Do not edit manually. */

/* tslint:disable */
/* eslint-disable */

/*
  Fuels version: {{FUELS}}
  Forc version: {{FORC}}
  Fuel-Core version: {{FUEL_CORE}}
*/
`;function E(p){let{data:r,template:t}=p,e={strict:!0,noEscape:!0},i=pt(t,e),o=pt(nt,e);return i({...r,header:o(xt)}).replace(/[\n]{3,}/gm,`

`)}var ot=`{{header}}

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels';

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}


interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;function at(p){let{name:r,types:t,functions:e,commonTypesInUse:i}=p.abi,o=e.map(u=>u.getDeclaration()),a=e.map(u=>u.attributes.name),c=e.map(u=>({functionName:u.attributes.name,input:u.attributes.inputs})),f=e.map(u=>({functionName:u.attributes.name})),m=t.filter(u=>u.name==="struct").map(u=>{let l=u,g=l.getStructName(),h=l.getStructContents({types:t,target:"input"}),C=l.getStructContents({types:t,target:"output"}),Rt=l.getStructDeclaration({types:t});return{structName:g,typeAnnotations:Rt,inputValues:h,outputValues:C,recycleRef:h===C}}),y=t.filter(u=>u.name==="enum").map(u=>{let l=u,g=l.getStructName(),h=l.getStructContents({types:t,target:"input"}),C=l.getStructContents({types:t,target:"output"});return{structName:g,inputValues:h,outputValues:C,recycleRef:h===C}});return E({template:ot,data:{capitalizedName:r,commonTypesInUse:i.join(", "),functionsTypedefs:o,functionsFragments:a,encoders:c,decoders:f,structs:m,enums:y}})}var ct=`{{header}}

import { Interface, Contract } from "fuels";
import type { Provider, Account, AbstractAddress } from "fuels";
import type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";

const _abi = {{abiJsonString}}

export class {{capitalizedName}}__factory {
  static readonly abi = _abi
  static createInterface(): {{capitalizedName}}Interface {
    return new Interface(_abi) as unknown as {{capitalizedName}}Interface
  }
  static connect(
    id: string | AbstractAddress,
    accountOrProvider: Account | Provider
  ): {{capitalizedName}} {
    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}
  }
}
`;function ut(p){let{name:r,rawContents:t}=p.abi,e=JSON.stringify(t,null,2);return E({template:ct,data:{capitalizedName:r,abiJsonString:e}})}import Nt from"lodash.upperfirst";function mt(p){let t=[e=>e.replace(/\s+/g,"-"),e=>e.replace(/\./g,"-"),e=>e.replace(/_/g,"-"),e=>e.replace(/-[a-z]/g,i=>i.slice(-1).toUpperCase()),e=>e.replace(/-/g,""),e=>e.replace(/^\d+/,""),e=>Nt(e)].reduce((e,i)=>i(e),p);if(t==="")throw new Error(`Can't guess class name, please rename file: ${p}`);return t}function I(p){let{types:r,typeId:t}=p,e=r.find(({rawAbiType:{typeId:i}})=>i===t);if(!e)throw new Error(`Type ID not found: ${t}.`);return e.parseComponentsAttributes({types:r}),e}function d(p){let{types:r,typeArguments:t,parentTypeId:e,target:i}=p,o=`${i}Label`,a=[],c,f;e!==void 0&&(c=I({types:r,typeId:e}),f=c.attributes[o]),t.forEach(y=>{let T,u=y.type;try{T=I({types:r,typeId:u}).attributes[o]}catch{T="void"}if(y.typeArguments){let l=d({types:r,target:i,parentTypeId:y.type,typeArguments:y.typeArguments});a.push(l)}else a.push(`${T}`)});let m=a.join(", ");return f&&(m=`${f}<${m}>`),m}var z=class{constructor(r){this.types=r.types,this.rawAbiFunction=r.rawAbiFunction,this.attributes={name:this.rawAbiFunction.name,inputs:this.bundleInputTypes(),output:this.bundleOutputTypes(),prefixedInputs:this.bundleInputTypes(!0)}}bundleInputTypes(r=!1){let{types:t}=this;return this.rawAbiFunction.inputs.map(i=>{let{name:o,type:a,typeArguments:c}=i,f=I({types:t,typeId:a}),m;return c?m=d({types:t,target:"input",parentTypeId:a,typeArguments:c}):m=f.attributes.inputLabel,r?`${o}: ${m}`:m}).join(", ")}bundleOutputTypes(){return d({types:this.types,target:"output",typeArguments:[this.rawAbiFunction.output]})}getDeclaration(){let{name:r,prefixedInputs:t,output:e}=this.attributes;return`${r}: InvokeFunction<[${t}], ${e}>`}};function yt(p){let{types:r,rawAbiFunction:t}=p;return new z({types:r,rawAbiFunction:t})}function lt(p){let{types:r,rawAbiFunctions:t}=p;return t.map(i=>yt({types:r,rawAbiFunction:i}))}var b=class{constructor(r){this.rawAbiType=r.rawAbiType,this.attributes={inputLabel:"unknown",outputLabel:"unknown"}}};var P=class extends b{constructor(){super(...arguments);this.name="array"}static isSuitableFor(t){return P.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var y,T;let{types:e}=t,{type:i}=this.rawAbiType,o=Number((y=i.match(P.MATCH_REGEX))==null?void 0:y[1]),a=[],c=[];(T=this.rawAbiType.components)==null||T.forEach(u=>{let{type:l,typeArguments:g}=u;if(g){let h=d({types:e,typeArguments:g,parentTypeId:l,target:"input"}),C=d({types:e,typeArguments:g,parentTypeId:l,target:"output"});a.push(h),c.push(C)}else{let{attributes:h}=I({types:e,typeId:l});a.push(h.inputLabel),c.push(h.outputLabel)}});let f=Array(o).fill(a[0]).join(", "),m=Array(o).fill(c[0]).join(", ");return this.attributes={inputLabel:`[${f}]`,outputLabel:`[${m}]`},this.attributes}},R=P;R.swayType="[_; 2]",R.MATCH_REGEX=/^\[_; ([0-9]+)\]$/m;var K=class extends b{constructor(){super(...arguments);this.name="str"}static isSuitableFor(t){return K.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"string",outputLabel:"string"},this.attributes}},w=K;w.swayType="str[3]",w.MATCH_REGEX=/^str\[(.+)\]$/m;var q=class extends w{constructor(){super(...arguments);this.name="b256"}static isSuitableFor(t){return q.MATCH_REGEX.test(t.type)}},x=q;x.swayType="b256",x.MATCH_REGEX=/^b256$/m;var Q=class extends x{constructor(){super(...arguments);this.name="b512"}static isSuitableFor(t){return Q.MATCH_REGEX.test(t.type)}},S=Q;S.swayType="b512",S.MATCH_REGEX=/^b512$/m;var W=class extends b{constructor(){super(...arguments);this.name="bool"}static isSuitableFor(t){return W.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"boolean",outputLabel:"boolean"},this.attributes}},_=W;_.swayType="bool",_.MATCH_REGEX=/^bool$/m;function G(p){var i;let{rawAbiType:r,regex:t}=p,e=(i=r.type.match(p.regex))==null?void 0:i[1];if(!e){let o=`Couldn't extract struct name with: '${t}'.

`;throw o+=`Check your JSON ABI.

[source]
`,o+=`${JSON.stringify(r,null,2)}`,new Error(o)}return e}var k=class extends b{constructor(){super(...arguments);this.name="enum"}static isSuitableFor(t){let e=k.MATCH_REGEX.test(t.type),i=k.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return G({rawAbiType:this.rawAbiType,regex:k.MATCH_REGEX})}getStructContents(t){let{types:e,target:i}=t,{components:o}=this.rawAbiType,a=o,c=`${i}Label`;return a.map(m=>{let{name:y,type:T}=m;if(T===0)return`${y}: []`;let{attributes:u}=I({types:e,typeId:T});return`${y}: ${u[c]}`}).join(", ")}},N=k;N.swayType="enum MyEnumName",N.MATCH_REGEX=/^enum (.+)$/m,N.IGNORE_REGEX=/^enum Option$/m;var v=class extends b{constructor(){super(...arguments);this.name="generic"}static isSuitableFor(t){return v.MATCH_REGEX.test(t.type)}getStructName(){return G({rawAbiType:this.rawAbiType,regex:v.MATCH_REGEX})}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={inputLabel:e,outputLabel:e},this.attributes}},M=v;M.swayType="generic T",M.MATCH_REGEX=/^generic ([^\s]+)$/m;var Y=class extends b{constructor(){super(...arguments);this.name="option"}static isSuitableFor(t){return Y.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"Option",outputLabel:"Option"},this.attributes}},H=Y;H.swayType="enum Option",H.MATCH_REGEX=/^enum Option$/m;var Z=class extends b{constructor(t){super(t);this.name="u8";this.attributes={inputLabel:"BigNumberish",outputLabel:"number"}}static isSuitableFor(t){return Z.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes}},A=Z;A.swayType="u8",A.MATCH_REGEX=/^u8$/m;var tt=class extends A{constructor(){super(...arguments);this.name="u64"}parseComponentsAttributes(t){return this.attributes={inputLabel:"BigNumberish",outputLabel:"BN"},this.attributes}static isSuitableFor(t){return tt.MATCH_REGEX.test(t.type)}},F=tt;F.swayType="u64",F.MATCH_REGEX=/^u64$/m;var et=class extends F{constructor(){super(...arguments);this.name="rawUntypedPtr"}static isSuitableFor(t){return et.MATCH_REGEX.test(t.type)}},X=et;X.swayType="raw untyped ptr",X.MATCH_REGEX=/^raw untyped ptr$/m;var V=class extends b{constructor(){super(...arguments);this.name="struct"}static isSuitableFor(t){let e=V.MATCH_REGEX.test(t.type),i=V.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return G({rawAbiType:this.rawAbiType,regex:V.MATCH_REGEX})}getStructContents(t){let{types:e,target:i}=t,{components:o}=this.rawAbiType;return o.map(f=>{let{name:m,type:y,typeArguments:T}=f,u=I({types:e,typeId:y}),l;if(T)l=d({types:e,target:i,parentTypeId:y,typeArguments:T});else{let g=`${i}Label`;l=u.attributes[g]}return`${m}: ${l}`}).join(", ")}getStructDeclaration(t){let{types:e}=t,{typeParameters:i}=this.rawAbiType;return i?`<${i.map(c=>I({types:e,typeId:c})).map(({attributes:{inputLabel:c}})=>c).join(", ")}>`:""}},$=V;$.swayType="struct MyStruct",$.MATCH_REGEX=/^struct (.+)$/m,$.IGNORE_REGEX=/^struct (Vec|RawVec)$/m;var rt=class extends b{constructor(){super(...arguments);this.name="tupple"}static isSuitableFor(t){return rt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var a;let{types:e}=t,i=[],o=[];return(a=this.rawAbiType.components)==null||a.forEach(c=>{let{type:f,typeArguments:m}=c;if(m){let y=d({types:e,typeArguments:m,parentTypeId:f,target:"input"}),T=d({types:e,typeArguments:m,parentTypeId:f,target:"output"});i.push(y),o.push(T)}else{let{attributes:y}=I({types:e,typeId:f});i.push(y.inputLabel),o.push(y.outputLabel)}}),this.attributes={inputLabel:`[${i.join(", ")}]`,outputLabel:`[${o.join(", ")}]`},this.attributes}},O=rt;O.swayType="(_, _, _)",O.MATCH_REGEX=/^\([_,\s]+\)$/m;var it=class extends A{constructor(){super(...arguments);this.name="u16"}static isSuitableFor(t){return it.MATCH_REGEX.test(t.type)}},U=it;U.swayType="u16",U.MATCH_REGEX=/^u16$/m;var st=class extends A{constructor(){super(...arguments);this.name="u32"}static isSuitableFor(t){return st.MATCH_REGEX.test(t.type)}},D=st;D.swayType="u32",D.MATCH_REGEX=/^u32$/m;var j=class extends R{constructor(){super(...arguments);this.name="vector"}static isSuitableFor(t){let e=j.MATCH_REGEX.test(t.type),i=j.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){return this.attributes={inputLabel:"Vec",outputLabel:"Vec"},this.attributes}},L=j;L.swayType="struct Vec",L.MATCH_REGEX=/^struct Vec/m,L.IGNORE_REGEX=/^struct RawVec$/m;var bt=[R,x,S,_,N,M,H,X,w,$,O,U,D,F,A,L];function ft(p){let{rawAbiType:r}=p,{type:t}=r,e=bt.find(i=>i.isSuitableFor({type:t}));if(!e)throw new Error(`Type not supported: ${t}`);return new e(p)}function Tt(p){return["()","struct RawVec"].indexOf(p.type)>=0}function It(p){let r=[];return p.rawAbiTypes.forEach(t=>{let{type:e}=t;if(!Tt({type:e})){let o=ft({rawAbiType:t});r.push(o)}}),r.forEach(t=>{t.parseComponentsAttributes({types:r})}),r}var B=class{constructor(r){this.commonTypesInUse=[];let{filepath:t,outputDir:e,rawContents:i}=r,o=/([^/]+)-abi\.json$/m,a=t.match(o);if(!a||a.length===0)throw new Error(`Could not parse name from abi file: ${t}`);let c=`${mt(a[1])}Abi`;this.dtsFilepath=`${e}/${c}.d.ts`,this.factoryFilepath=`${e}/factories/${c}__factory.ts`,this.name=c,this.filepath=t,this.rawContents=i,this.outputDir=e;let{types:f,functions:m}=this.parse();this.types=f,this.functions=m,this.computeCommonTypesInUse()}parse(){let{types:r,functions:t}=this.rawContents,e=It({rawAbiTypes:r}),i=lt({rawAbiFunctions:t,types:e});return{types:e,functions:i}}getDtsDeclaration(){return at({abi:this})}getFactoryDeclaration(){return ut({abi:this})}computeCommonTypesInUse(){let r={option:"Option",enum:"Enum",vector:"Vec"};this.commonTypesInUse=[],Object.keys(r).forEach(t=>{if(!!this.types.find(i=>i.name===t)){let i=r[t];this.commonTypesInUse.push(i)}})}};var dt=`{{header}}

/*
  Mimics Sway Enum, requires at least one Key-Value but
  does not raise error on multiple pairs.
  This is done in the abi-coder
*/
export type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

/*
  Mimics Sway Option and Vectors.
  Vectors are treated like arrays in Typescript.
*/
export type Option<T> = T | undefined;

export type Vec<T> = T[];
`;function At(){return E({template:dt})}var ht=`{{header}}

{{#each abiCapitalizedNames}}
export type { {{this}} } from './{{this}}';
{{/each}}

{{#each abiCapitalizedNames}}
export { {{this}}__factory } from './factories/{{this}}__factory';
{{/each}}
`;function gt(p){let r=p.abis.map(({name:e})=>e);return E({template:ht,data:{abiCapitalizedNames:r}})}var Et=class{constructor(r){let{abiFiles:t,outputDir:e}=r;this.files=[],this.outputDir=e,this.abiFiles=t,this.abis=this.abiFiles.map(i=>new B({filepath:i.path,rawContents:JSON.parse(i.contents),outputDir:e})),this.assembleAllFiles()}assembleAllFiles(){let r=this.abis.find(e=>e.commonTypesInUse.length>0);this.abis.forEach(e=>{let i={path:e.dtsFilepath,contents:e.getDtsDeclaration()},o={path:e.factoryFilepath,contents:e.getFactoryDeclaration()};this.files.push(i),this.files.push(o)});let t={path:`${this.outputDir}/index.ts`,contents:gt({abis:this.abis})};if(this.files.push(t),r){let i={path:St(this.outputDir,"common.d.ts"),contents:At()};this.files.push(i)}}};export{Et as AbiTypeGen};
//# sourceMappingURL=index.mjs.map