"use strict";var Dt=Object.create;var P=Object.defineProperty;var kt=Object.getOwnPropertyDescriptor;var Pt=Object.getOwnPropertyNames;var Vt=Object.getPrototypeOf,vt=Object.prototype.hasOwnProperty;var zt=(n,r)=>{for(var t in r)P(n,t,{get:r[t],enumerable:!0})},ct=(n,r,t,e)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of Pt(r))!vt.call(n,i)&&i!==t&&P(n,i,{get:()=>r[i],enumerable:!(e=kt(r,i))||e.enumerable});return n};var q=(n,r,t)=>(t=n!=null?Dt(Vt(n)):{},ct(r||!n||!n.__esModule?P(t,"default",{value:n,enumerable:!0}):t,n)),jt=n=>ct(P({},"__esModule",{value:!0}),n);var Wt={};zt(Wt,{configureCliOptions:()=>Ot,run:()=>Qt,runCliAction:()=>Xt});module.exports=jt(Wt);var Mt=require("@fuel-ts/versions"),Ht=require("commander");var K=require("fs"),$t=require("glob"),St=q(require("mkdirp")),Lt=require("path"),Gt=q(require("rimraf"));var Nt=require("path");var mt=require("@fuel-ts/versions"),Y=require("handlebars");var ut=`/* Autogenerated file. Do not edit manually. */

/* tslint:disable */
/* eslint-disable */

/*
  Fuels version: {{FUELS}}
  Forc version: {{FORC}}
  Fuel-Core version: {{FUEL_CORE}}
*/
`;function A(n){let{data:r,template:t}=n,e={strict:!0,noEscape:!0},i=(0,Y.compile)(t,e),s=(0,Y.compile)(ut,e);return i({...r,header:s(mt.versions)}).replace(/[\n]{3,}/gm,`

`)}var yt=`{{header}}

import type {
  Interface,
  FunctionFragment,
  DecodedValue,
  Contract,
  BytesLike,
  BigNumberish,
  InvokeFunction,
  BN,
} from 'fuels';

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
{{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}


interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;function lt(n){let{name:r,types:t,functions:e,commonTypesInUse:i}=n.abi,s=e.map(a=>a.getDeclaration()),c=e.map(a=>a.attributes.name),o=e.map(a=>({functionName:a.attributes.name,input:a.attributes.inputs})),y=e.map(a=>({functionName:a.attributes.name})),m=t.filter(a=>a.name==="struct").map(a=>{let b=a,h=b.getStructName(),g=b.getStructContents({types:t,target:"input"}),F=b.getStructContents({types:t,target:"output"}),Ut=b.getStructDeclaration({types:t});return{structName:h,typeAnnotations:Ut,inputValues:g,outputValues:F,recycleRef:g===F}}),l=t.filter(a=>a.name==="enum").map(a=>{let b=a,h=b.getStructName(),g=b.getStructContents({types:t,target:"input"}),F=b.getStructContents({types:t,target:"output"});return{structName:h,inputValues:g,outputValues:F,recycleRef:g===F}});return A({template:yt,data:{capitalizedName:r,commonTypesInUse:i.join(", "),functionsTypedefs:s,functionsFragments:c,encoders:o,decoders:y,structs:m,enums:l}})}var bt=`{{header}}

import { Interface, Contract } from "fuels";
import type { Provider, Account, AbstractAddress } from "fuels";
import type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";

const _abi = {{abiJsonString}}

export class {{capitalizedName}}__factory {
  static readonly abi = _abi
  static createInterface(): {{capitalizedName}}Interface {
    return new Interface(_abi) as unknown as {{capitalizedName}}Interface
  }
  static connect(
    id: string | AbstractAddress,
    accountOrProvider: Account | Provider
  ): {{capitalizedName}} {
    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}
  }
}
`;function ft(n){let{name:r,rawContents:t}=n.abi,e=JSON.stringify(t,null,2);return A({template:bt,data:{capitalizedName:r,abiJsonString:e}})}var Tt=q(require("lodash.upperfirst"));function It(n){let t=[e=>e.replace(/\s+/g,"-"),e=>e.replace(/\./g,"-"),e=>e.replace(/_/g,"-"),e=>e.replace(/-[a-z]/g,i=>i.slice(-1).toUpperCase()),e=>e.replace(/-/g,""),e=>e.replace(/^\d+/,""),e=>(0,Tt.default)(e)].reduce((e,i)=>i(e),n);if(t==="")throw new Error(`Can't guess class name, please rename file: ${n}`);return t}function T(n){let{types:r,typeId:t}=n,e=r.find(({rawAbiType:{typeId:i}})=>i===t);if(!e)throw new Error(`Type ID not found: ${t}.`);return e.parseComponentsAttributes({types:r}),e}function I(n){let{types:r,typeArguments:t,parentTypeId:e,target:i}=n,s=`${i}Label`,c=[],o,y;e!==void 0&&(o=T({types:r,typeId:e}),y=o.attributes[s]),t.forEach(l=>{let u,a=l.type;try{u=T({types:r,typeId:a}).attributes[s]}catch{u="void"}if(l.typeArguments){let b=I({types:r,target:i,parentTypeId:l.type,typeArguments:l.typeArguments});c.push(b)}else c.push(`${u}`)});let m=c.join(", ");return y&&(m=`${y}<${m}>`),m}var V=class{constructor(r){this.types=r.types,this.rawAbiFunction=r.rawAbiFunction,this.attributes={name:this.rawAbiFunction.name,inputs:this.bundleInputTypes(),output:this.bundleOutputTypes(),prefixedInputs:this.bundleInputTypes(!0)}}bundleInputTypes(r=!1){let{types:t}=this;return this.rawAbiFunction.inputs.map(i=>{let{name:s,type:c,typeArguments:o}=i,y=T({types:t,typeId:c}),m;return o?m=I({types:t,target:"input",parentTypeId:c,typeArguments:o}):m=y.attributes.inputLabel,r?`${s}: ${m}`:m}).join(", ")}bundleOutputTypes(){return I({types:this.types,target:"output",typeArguments:[this.rawAbiFunction.output]})}getDeclaration(){let{name:r,prefixedInputs:t,output:e}=this.attributes;return`${r}: InvokeFunction<[${t}], ${e}>`}};function dt(n){let{types:r,rawAbiFunction:t}=n;return new V({types:r,rawAbiFunction:t})}function gt(n){let{types:r,rawAbiFunctions:t}=n;return t.map(i=>dt({types:r,rawAbiFunction:i}))}var f=class{constructor(r){this.rawAbiType=r.rawAbiType,this.attributes={inputLabel:"unknown",outputLabel:"unknown"}}};var v=class extends f{constructor(){super(...arguments);this.name="array"}static isSuitableFor(t){return v.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var l,u;let{types:e}=t,{type:i}=this.rawAbiType,s=Number((l=i.match(v.MATCH_REGEX))==null?void 0:l[1]),c=[],o=[];(u=this.rawAbiType.components)==null||u.forEach(a=>{let{type:b,typeArguments:h}=a;if(h){let g=I({types:e,typeArguments:h,parentTypeId:b,target:"input"}),F=I({types:e,typeArguments:h,parentTypeId:b,target:"output"});c.push(g),o.push(F)}else{let{attributes:g}=T({types:e,typeId:b});c.push(g.inputLabel),o.push(g.outputLabel)}});let y=Array(s).fill(c[0]).join(", "),m=Array(s).fill(o[0]).join(", ");return this.attributes={inputLabel:`[${y}]`,outputLabel:`[${m}]`},this.attributes}},E=v;E.swayType="[_; 2]",E.MATCH_REGEX=/^\[_; ([0-9]+)\]$/m;var W=class extends f{constructor(){super(...arguments);this.name="str"}static isSuitableFor(t){return W.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"string",outputLabel:"string"},this.attributes}},w=W;w.swayType="str[3]",w.MATCH_REGEX=/^str\[(.+)\]$/m;var Z=class extends w{constructor(){super(...arguments);this.name="b256"}static isSuitableFor(t){return Z.MATCH_REGEX.test(t.type)}},R=Z;R.swayType="b256",R.MATCH_REGEX=/^b256$/m;var tt=class extends R{constructor(){super(...arguments);this.name="b512"}static isSuitableFor(t){return tt.MATCH_REGEX.test(t.type)}},S=tt;S.swayType="b512",S.MATCH_REGEX=/^b512$/m;var et=class extends f{constructor(){super(...arguments);this.name="bool"}static isSuitableFor(t){return et.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"boolean",outputLabel:"boolean"},this.attributes}},L=et;L.swayType="bool",L.MATCH_REGEX=/^bool$/m;function G(n){var i;let{rawAbiType:r,regex:t}=n,e=(i=r.type.match(n.regex))==null?void 0:i[1];if(!e){let s=`Couldn't extract struct name with: '${t}'.

`;throw s+=`Check your JSON ABI.

[source]
`,s+=`${JSON.stringify(r,null,2)}`,new Error(s)}return e}var D=class extends f{constructor(){super(...arguments);this.name="enum"}static isSuitableFor(t){let e=D.MATCH_REGEX.test(t.type),i=D.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return G({rawAbiType:this.rawAbiType,regex:D.MATCH_REGEX})}getStructContents(t){let{types:e,target:i}=t,{components:s}=this.rawAbiType,c=s,o=`${i}Label`;return c.map(m=>{let{name:l,type:u}=m;if(u===0)return`${l}: []`;let{attributes:a}=T({types:e,typeId:u});return`${l}: ${a[o]}`}).join(", ")}},C=D;C.swayType="enum MyEnumName",C.MATCH_REGEX=/^enum (.+)$/m,C.IGNORE_REGEX=/^enum Option$/m;var z=class extends f{constructor(){super(...arguments);this.name="generic"}static isSuitableFor(t){return z.MATCH_REGEX.test(t.type)}getStructName(){return G({rawAbiType:this.rawAbiType,regex:z.MATCH_REGEX})}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={inputLabel:e,outputLabel:e},this.attributes}},_=z;_.swayType="generic T",_.MATCH_REGEX=/^generic ([^\s]+)$/m;var rt=class extends f{constructor(){super(...arguments);this.name="option"}static isSuitableFor(t){return rt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes={inputLabel:"Option",outputLabel:"Option"},this.attributes}},M=rt;M.swayType="enum Option",M.MATCH_REGEX=/^enum Option$/m;var it=class extends f{constructor(t){super(t);this.name="u8";this.attributes={inputLabel:"BigNumberish",outputLabel:"number"}}static isSuitableFor(t){return it.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){return this.attributes}},d=it;d.swayType="u8",d.MATCH_REGEX=/^u8$/m;var nt=class extends d{constructor(){super(...arguments);this.name="u64"}parseComponentsAttributes(t){return this.attributes={inputLabel:"BigNumberish",outputLabel:"BN"},this.attributes}static isSuitableFor(t){return nt.MATCH_REGEX.test(t.type)}},x=nt;x.swayType="u64",x.MATCH_REGEX=/^u64$/m;var st=class extends x{constructor(){super(...arguments);this.name="rawUntypedPtr"}static isSuitableFor(t){return st.MATCH_REGEX.test(t.type)}},H=st;H.swayType="raw untyped ptr",H.MATCH_REGEX=/^raw untyped ptr$/m;var k=class extends f{constructor(){super(...arguments);this.name="struct"}static isSuitableFor(t){let e=k.MATCH_REGEX.test(t.type),i=k.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){let e=this.getStructName();return this.attributes={structName:e,inputLabel:`${e}Input`,outputLabel:`${e}Output`},this.attributes}getStructName(){return G({rawAbiType:this.rawAbiType,regex:k.MATCH_REGEX})}getStructContents(t){let{types:e,target:i}=t,{components:s}=this.rawAbiType;return s.map(y=>{let{name:m,type:l,typeArguments:u}=y,a=T({types:e,typeId:l}),b;if(u)b=I({types:e,target:i,parentTypeId:l,typeArguments:u});else{let h=`${i}Label`;b=a.attributes[h]}return`${m}: ${b}`}).join(", ")}getStructDeclaration(t){let{types:e}=t,{typeParameters:i}=this.rawAbiType;return i?`<${i.map(o=>T({types:e,typeId:o})).map(({attributes:{inputLabel:o}})=>o).join(", ")}>`:""}},N=k;N.swayType="struct MyStruct",N.MATCH_REGEX=/^struct (.+)$/m,N.IGNORE_REGEX=/^struct (Vec|RawVec)$/m;var pt=class extends f{constructor(){super(...arguments);this.name="tupple"}static isSuitableFor(t){return pt.MATCH_REGEX.test(t.type)}parseComponentsAttributes(t){var c;let{types:e}=t,i=[],s=[];return(c=this.rawAbiType.components)==null||c.forEach(o=>{let{type:y,typeArguments:m}=o;if(m){let l=I({types:e,typeArguments:m,parentTypeId:y,target:"input"}),u=I({types:e,typeArguments:m,parentTypeId:y,target:"output"});i.push(l),s.push(u)}else{let{attributes:l}=T({types:e,typeId:y});i.push(l.inputLabel),s.push(l.outputLabel)}}),this.attributes={inputLabel:`[${i.join(", ")}]`,outputLabel:`[${s.join(", ")}]`},this.attributes}},X=pt;X.swayType="(_, _, _)",X.MATCH_REGEX=/^\([_,\s]+\)$/m;var ot=class extends d{constructor(){super(...arguments);this.name="u16"}static isSuitableFor(t){return ot.MATCH_REGEX.test(t.type)}},O=ot;O.swayType="u16",O.MATCH_REGEX=/^u16$/m;var at=class extends d{constructor(){super(...arguments);this.name="u32"}static isSuitableFor(t){return at.MATCH_REGEX.test(t.type)}},U=at;U.swayType="u32",U.MATCH_REGEX=/^u32$/m;var j=class extends E{constructor(){super(...arguments);this.name="vector"}static isSuitableFor(t){let e=j.MATCH_REGEX.test(t.type),i=j.IGNORE_REGEX.test(t.type);return e&&!i}parseComponentsAttributes(t){return this.attributes={inputLabel:"Vec",outputLabel:"Vec"},this.attributes}},$=j;$.swayType="struct Vec",$.MATCH_REGEX=/^struct Vec/m,$.IGNORE_REGEX=/^struct RawVec$/m;var ht=[E,R,S,L,C,_,M,H,w,N,X,O,U,x,d,$];function At(n){let{rawAbiType:r}=n,{type:t}=r,e=ht.find(i=>i.isSuitableFor({type:t}));if(!e)throw new Error(`Type not supported: ${t}`);return new e(n)}function Et(n){return["()","struct RawVec"].indexOf(n.type)>=0}function wt(n){let r=[];return n.rawAbiTypes.forEach(t=>{let{type:e}=t;if(!Et({type:e})){let s=At({rawAbiType:t});r.push(s)}}),r.forEach(t=>{t.parseComponentsAttributes({types:r})}),r}var B=class{constructor(r){this.commonTypesInUse=[];let{filepath:t,outputDir:e,rawContents:i}=r,s=/([^/]+)-abi\.json$/m,c=t.match(s);if(!c||c.length===0)throw new Error(`Could not parse name from abi file: ${t}`);let o=`${It(c[1])}Abi`;this.dtsFilepath=`${e}/${o}.d.ts`,this.factoryFilepath=`${e}/factories/${o}__factory.ts`,this.name=o,this.filepath=t,this.rawContents=i,this.outputDir=e;let{types:y,functions:m}=this.parse();this.types=y,this.functions=m,this.computeCommonTypesInUse()}parse(){let{types:r,functions:t}=this.rawContents,e=wt({rawAbiTypes:r}),i=gt({rawAbiFunctions:t,types:e});return{types:e,functions:i}}getDtsDeclaration(){return lt({abi:this})}getFactoryDeclaration(){return ft({abi:this})}computeCommonTypesInUse(){let r={option:"Option",enum:"Enum",vector:"Vec"};this.commonTypesInUse=[],Object.keys(r).forEach(t=>{if(!!this.types.find(i=>i.name===t)){let i=r[t];this.commonTypesInUse.push(i)}})}};var Rt=`{{header}}

/*
  Mimics Sway Enum, requires at least one Key-Value but
  does not raise error on multiple pairs.
  This is done in the abi-coder
*/
export type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

/*
  Mimics Sway Option and Vectors.
  Vectors are treated like arrays in Typescript.
*/
export type Option<T> = T | undefined;

export type Vec<T> = T[];
`;function xt(){return A({template:Rt})}var Ft=`{{header}}

{{#each abiCapitalizedNames}}
export type { {{this}} } from './{{this}}';
{{/each}}

{{#each abiCapitalizedNames}}
export { {{this}}__factory } from './factories/{{this}}__factory';
{{/each}}
`;function Ct(n){let r=n.abis.map(({name:e})=>e);return A({template:Ft,data:{abiCapitalizedNames:r}})}var J=class{constructor(r){let{abiFiles:t,outputDir:e}=r;this.files=[],this.outputDir=e,this.abiFiles=t,this.abis=this.abiFiles.map(i=>new B({filepath:i.path,rawContents:JSON.parse(i.contents),outputDir:e})),this.assembleAllFiles()}assembleAllFiles(){let r=this.abis.find(e=>e.commonTypesInUse.length>0);this.abis.forEach(e=>{let i={path:e.dtsFilepath,contents:e.getDtsDeclaration()},s={path:e.factoryFilepath,contents:e.getFactoryDeclaration()};this.files.push(i),this.files.push(s)});let t={path:`${this.outputDir}/index.ts`,contents:Ct({abis:this.abis})};if(this.files.push(t),r){let i={path:(0,Nt.join)(this.outputDir,"common.d.ts"),contents:xt()};this.files.push(i)}}};function _t(n){let{cwd:r,inputs:t,output:e,silent:i,filepaths:s}=n,c=(0,Lt.basename)(r),{log:o}=console;i&&(o=()=>({}));let y=[];if(!(s!=null&&s.length)&&(t==null?void 0:t.length))y=t.flatMap(u=>(0,$t.sync)(u,{cwd:r}));else if(s!=null&&s.length)y=s;else throw new Error("You need to inform at least one parameter: `input` or `filepaths`");let m=y.map(u=>({path:u,contents:(0,K.readFileSync)(u,"utf-8")})),l=new J({outputDir:e,abiFiles:m});o(`Generating files..
`),St.default.sync(`${e}/factories`),l.files.forEach(u=>{Gt.default.sync(u.path),(0,K.writeFileSync)(u.path,u.contents);let a=new RegExp(`^.+${c}/`,"m");o(` - ${u.path.replace(a,"")}`)}),o(`
Done.\u26A1`)}function Xt(n){let r=process.cwd(),{inputs:t,output:e,silent:i}=n;_t({cwd:r,inputs:t,output:e,silent:!!i})}function Ot(n){n.requiredOption("-i, --inputs <path|glob...>","input paths/globals to your abi json files").requiredOption("-o, --output <dir>","directory path for generated files").option("-s, --silent","omit output messages").action(Xt)}function Qt(n){let r=new Ht.Command,{argv:t,programName:e}=n;r.name(e),r.version(Mt.versions.FUELS),r.usage("-i ../out/*-abi.json -o ./generated/"),Ot(r),r.parse(t)}0&&(module.exports={configureCliOptions,run,runCliAction});
//# sourceMappingURL=cli.js.map