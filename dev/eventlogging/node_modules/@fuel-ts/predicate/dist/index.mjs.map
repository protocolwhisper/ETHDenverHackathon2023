{"version":3,"sources":["../src/predicate.ts","../src/utils/getContractRoot.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { AbiCoder, Interface } from '@fuel-ts/abi-coder';\nimport type { JsonAbiFragmentType, JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport { Address } from '@fuel-ts/address';\nimport type {\n  CallResult,\n  Provider,\n  TransactionRequestLike,\n  TransactionResponse,\n} from '@fuel-ts/providers';\nimport { transactionRequestify } from '@fuel-ts/providers';\nimport { InputType } from '@fuel-ts/transactions';\nimport { versions } from '@fuel-ts/versions';\nimport { Account } from '@fuel-ts/wallet';\n\nimport { getContractRoot } from './utils';\n\nconst logger = new Logger(versions.FUELS);\n\nexport class Predicate<ARGS extends InputValue[]> extends Account {\n  bytes: Uint8Array;\n  types?: ReadonlyArray<JsonAbiFragmentType>;\n  predicateData: Uint8Array = Uint8Array.from([]);\n  interface?: Interface;\n\n  constructor(bytes: BytesLike, types?: JsonAbi, provider?: string | Provider) {\n    const address = Address.fromB256(getContractRoot(bytes));\n    super(address, provider);\n\n    // Assign bytes data\n    this.bytes = arrayify(bytes);\n\n    if (types) {\n      this.interface = new Interface(types as JsonAbi);\n      const mainFunction = this.interface.fragments.find(({ name }) => name === 'main');\n      if (mainFunction !== undefined) {\n        this.types = mainFunction.inputs;\n      } else {\n        logger.throwArgumentError(\n          'Cannot use ABI without \"main\" function',\n          'Function fragments',\n          this.interface.fragments\n        );\n      }\n    }\n  }\n\n  populateTransactionPredicateData(transactionRequestLike: TransactionRequestLike) {\n    const request = transactionRequestify(transactionRequestLike);\n\n    request.inputs?.forEach((input) => {\n      if (input.type === InputType.Coin && hexlify(input.owner) === this.address.toB256()) {\n        // eslint-disable-next-line no-param-reassign\n        input.predicate = this.bytes;\n        // eslint-disable-next-line no-param-reassign\n        input.predicateData = this.predicateData;\n      }\n    });\n\n    return request;\n  }\n\n  sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.sendTransaction(transactionRequest);\n  }\n\n  simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.simulateTransaction(transactionRequest);\n  }\n\n  setData<T extends ARGS>(...args: T) {\n    const abiCoder = new AbiCoder();\n    const encoded = abiCoder.encode(this.types || [], args);\n    this.predicateData = encoded;\n    return this;\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport { calcRoot } from '@fuel-ts/merkle';\n\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 8;\n  const chunks: Uint8Array[] = [];\n  const bytes = arrayify(bytecode);\n\n  for (let offset = 0; offset < bytes.length; offset += chunkSize) {\n    const chunk = new Uint8Array(chunkSize);\n    chunk.set(bytes.slice(offset, offset + chunkSize));\n    chunks.push(chunk);\n  }\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n"],"mappings":"AACA,OAAS,WAAAA,EAAS,YAAAC,MAAgB,uBAClC,OAAS,UAAAC,MAAc,wBACvB,OAAS,YAAAC,EAAU,aAAAC,MAAiB,qBAEpC,OAAS,WAAAC,MAAe,mBAOxB,OAAS,yBAAAC,MAA6B,qBACtC,OAAS,aAAAC,MAAiB,wBAC1B,OAAS,YAAAC,MAAgB,oBACzB,OAAS,WAAAC,MAAe,kBCdxB,OAAS,WAAAC,EAAS,YAAAC,MAAgB,uBAClC,OAAS,YAAAC,MAAgB,kBAElB,IAAMC,EAAmBC,GAAgC,CAE9D,IAAMC,EAAuB,CAAC,EACxBC,EAAQL,EAASG,CAAQ,EAE/B,QAASG,EAAS,EAAGA,EAASD,EAAM,OAAQC,GAAU,EAAW,CAC/D,IAAMC,EAAQ,IAAI,WAAW,CAAS,EACtCA,EAAM,IAAIF,EAAM,MAAMC,EAAQA,EAAS,CAAS,CAAC,EACjDF,EAAO,KAAKG,CAAK,CACnB,CAEA,OAAON,EAASG,EAAO,IAAKI,GAAMT,EAAQS,CAAC,CAAC,CAAC,CAC/C,EDGA,IAAMC,EAAS,IAAIC,EAAOC,EAAS,KAAK,EAE3BC,EAAN,cAAmDC,CAAQ,CAMhE,YAAYC,EAAkBC,EAAiBC,EAA8B,CAC3E,IAAMC,EAAUC,EAAQ,SAASC,EAAgBL,CAAK,CAAC,EACvD,MAAMG,EAASD,CAAQ,EALzB,mBAA4B,WAAW,KAAK,CAAC,CAAC,EAQ5C,QAAK,MAAQI,EAASN,CAAK,EAEvBC,EAAO,CACT,KAAK,UAAY,IAAIM,EAAUN,CAAgB,EAC/C,IAAMO,EAAe,KAAK,UAAU,UAAU,KAAK,CAAC,CAAE,KAAAC,CAAK,IAAMA,IAAS,MAAM,EAC5ED,IAAiB,OACnB,KAAK,MAAQA,EAAa,OAE1Bb,EAAO,mBACL,yCACA,qBACA,KAAK,UAAU,SACjB,CAEJ,CACF,CAEA,iCAAiCe,EAAgD,CAjDnF,IAAAC,EAkDI,IAAMC,EAAUC,EAAsBH,CAAsB,EAE5D,OAAAC,EAAAC,EAAQ,SAAR,MAAAD,EAAgB,QAASG,GAAU,CAC7BA,EAAM,OAASC,EAAU,MAAQC,EAAQF,EAAM,KAAK,IAAM,KAAK,QAAQ,OAAO,IAEhFA,EAAM,UAAY,KAAK,MAEvBA,EAAM,cAAgB,KAAK,cAE/B,GAEOF,CACT,CAEA,gBAAgBF,EAA8E,CAC5F,IAAMO,EAAqB,KAAK,iCAAiCP,CAAsB,EACvF,OAAO,MAAM,gBAAgBO,CAAkB,CACjD,CAEA,oBAAoBP,EAAqE,CACvF,IAAMO,EAAqB,KAAK,iCAAiCP,CAAsB,EACvF,OAAO,MAAM,oBAAoBO,CAAkB,CACrD,CAEA,WAA2BC,EAAS,CAElC,IAAMC,EADW,IAAIC,EAAS,EACL,OAAO,KAAK,OAAS,CAAC,EAAGF,CAAI,EACtD,YAAK,cAAgBC,EACd,IACT,CACF","names":["hexlify","arrayify","Logger","AbiCoder","Interface","Address","transactionRequestify","InputType","versions","Account","hexlify","arrayify","calcRoot","getContractRoot","bytecode","chunks","bytes","offset","chunk","c","logger","Logger","versions","Predicate","Account","bytes","types","provider","address","Address","getContractRoot","arrayify","Interface","mainFunction","name","transactionRequestLike","_a","request","transactionRequestify","input","InputType","hexlify","transactionRequest","args","encoded","AbiCoder"]}