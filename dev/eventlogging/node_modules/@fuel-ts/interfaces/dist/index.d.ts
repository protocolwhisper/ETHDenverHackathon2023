type Bech32Address = `fuel${string}`;
type B256Address = string;
declare abstract class AbstractScriptRequest<T> {
    abstract bytes: Uint8Array;
    abstract encodeScriptData: (data: T) => Uint8Array;
}
declare abstract class AbstractAddress {
    abstract toJSON(): string;
    abstract toString(): string;
    abstract toAddress(): Bech32Address;
    abstract toB256(): B256Address;
    abstract toHexString(): string;
    abstract toBytes(): Uint8Array;
    abstract equals(other: AbstractAddress): boolean;
}
declare abstract class AbstractAccount {
    abstract address: AbstractAddress;
    abstract provider: unknown;
    abstract getResourcesToSpend(quantities: any[], options?: any): any;
    abstract sendTransaction(transactionRequest: any): any;
    abstract simulateTransaction(transactionRequest: any): any;
}
declare abstract class AbstractProgram {
    abstract account: AbstractAccount | null;
    abstract interface: {
        encodeFunctionData: (func: any, args: any[], offset: number, isMainArgs?: boolean) => any;
        decodeFunctionResult: (func: any, result: Uint8Array | string) => any;
        updateExternalLoggedTypes: (id: string, loggedTypes: any[]) => any;
        loggedTypes: any;
    };
    abstract provider: {
        sendTransaction(transactionRequest: any): any;
    } | null;
}
declare abstract class AbstractContract extends AbstractProgram {
    abstract id: AbstractAddress;
}
declare abstract class AbstractScript extends AbstractProgram {
    abstract bytes: Uint8Array;
}
type AddressLike = AbstractAddress | AbstractAccount;
type ContractIdLike = AbstractAddress | AbstractContract;
declare abstract class AbstractPredicate {
    abstract bytes: Uint8Array;
    abstract address: AbstractAddress;
    abstract predicateData: Uint8Array;
    abstract types?: ReadonlyArray<any>;
}

export { AbstractAccount, AbstractAddress, AbstractContract, AbstractPredicate, AbstractProgram, AbstractScript, AbstractScriptRequest, AddressLike, B256Address, Bech32Address, ContractIdLike };
