import { BytesLike } from '@ethersproject/bytes';
import { BigNumberish, BN } from '@fuel-ts/math';
import { AbstractAddress, AbstractScriptRequest, ContractIdLike, AddressLike } from '@fuel-ts/interfaces';
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { Network } from '@ethersproject/networks';
import { InputType, Input, OutputType, Output, TransactionType, TransactionScript, TransactionCreate, ReceiptCall, ReceiptReturn, ReceiptReturnData, ReceiptPanic, ReceiptRevert, ReceiptLog, ReceiptLogData, ReceiptTransfer, ReceiptTransferOut, ReceiptScriptResult, ReceiptMessageOut, Transaction } from '@fuel-ts/transactions';
export { TransactionType } from '@fuel-ts/transactions';
import { Interface } from '@fuel-ts/abi-coder';

type CoinQuantityLike = [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish] | {
    amount: BigNumberish;
    assetId?: BytesLike;
    max?: BigNumberish;
};
type CoinQuantity = {
    amount: BN;
    assetId: string;
    max?: BN;
};
declare const coinQuantityfy: (coinQuantityLike: CoinQuantityLike) => CoinQuantity;

type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Address: string;
    AssetId: string;
    BlockId: string;
    Bytes32: string;
    ContractId: string;
    HexString: string;
    MessageId: any;
    Salt: string;
    Signature: any;
    Tai64Timestamp: any;
    TransactionId: string;
    TxPointer: any;
    U64: string;
    UtxoId: string;
};
type GqlBalanceFilterInput = {
    /** Filter coins based on the `owner` field */
    owner: Scalars['Address'];
};
type GqlCoinFilterInput = {
    /** Returns coins only with `asset_id`. */
    assetId?: InputMaybe<Scalars['AssetId']>;
    /** Returns coins owned by the `owner`. */
    owner: Scalars['Address'];
};
declare enum GqlCoinStatus {
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
type GqlExcludeInput = {
    /** Messages to exclude from the selection. */
    messages: Array<Scalars['MessageId']>;
    /** Utxos to exclude from the selection. */
    utxos: Array<Scalars['UtxoId']>;
};
declare enum GqlMessageStatus {
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
declare enum GqlReturnType {
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT"
}
type GqlSpendQueryElementInput = {
    /** Target amount for the query. */
    amount: Scalars['U64'];
    /** Identifier of the asset to spend. */
    assetId: Scalars['AssetId'];
    /** The maximum number of currencies for selection. */
    max?: InputMaybe<Scalars['U64']>;
};
type GqlGetVersionQueryVariables = Exact<{
    [key: string]: never;
}>;
type GqlGetVersionQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
    };
};
type GqlGetInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
type GqlGetInfoQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
        minGasPrice: string;
    };
};
type GqlGetChainQueryVariables = Exact<{
    [key: string]: never;
}>;
type GqlGetChainQuery = {
    __typename: 'Query';
    chain: {
        __typename: 'ChainInfo';
        name: string;
        baseChainHeight: string;
        peerCount: number;
        consensusParameters: {
            __typename: 'ConsensusParameters';
            contractMaxSize: string;
            maxInputs: string;
            maxOutputs: string;
            maxWitnesses: string;
            maxGasPerTx: string;
            maxScriptLength: string;
            maxScriptDataLength: string;
            maxStorageSlots: string;
            maxPredicateLength: string;
            maxPredicateDataLength: string;
            gasPriceFactor: string;
            gasPerByte: string;
            maxMessageDataLength: string;
        };
        latestBlock: {
            __typename: 'Block';
            id: string;
            header: {
                __typename: 'Header';
                height: string;
                time: any;
            };
            transactions: Array<{
                __typename: 'Transaction';
                id: string;
            }>;
        };
    };
};
type GqlGetTransactionQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
type GqlGetTransactionQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        gasPrice?: string | null;
        status?: {
            __typename: 'FailureStatus';
            time: any;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SqueezedOutStatus';
            type: 'SqueezedOutStatus';
        } | {
            __typename: 'SubmittedStatus';
            time: any;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: any;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState?: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            } | null;
        } | null;
    } | null;
};
type GqlGetTransactionWithReceiptsQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
type GqlGetTransactionWithReceiptsQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        gasPrice?: string | null;
        receipts?: Array<{
            __typename: 'Receipt';
            data?: string | null;
            rawPayload: string;
        }> | null;
        status?: {
            __typename: 'FailureStatus';
            time: any;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SqueezedOutStatus';
            type: 'SqueezedOutStatus';
        } | {
            __typename: 'SubmittedStatus';
            time: any;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: any;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState?: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            } | null;
        } | null;
    } | null;
};
type GqlGetTransactionsQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetTransactionsQuery = {
    __typename: 'Query';
    transactions: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                gasPrice?: string | null;
                status?: {
                    __typename: 'FailureStatus';
                    time: any;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SqueezedOutStatus';
                    type: 'SqueezedOutStatus';
                } | {
                    __typename: 'SubmittedStatus';
                    time: any;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: any;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState?: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    } | null;
                } | null;
            };
        }>;
    };
};
type GqlGetTransactionsByOwnerQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetTransactionsByOwnerQuery = {
    __typename: 'Query';
    transactionsByOwner: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                gasPrice?: string | null;
                status?: {
                    __typename: 'FailureStatus';
                    time: any;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SqueezedOutStatus';
                    type: 'SqueezedOutStatus';
                } | {
                    __typename: 'SubmittedStatus';
                    time: any;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: any;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState?: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    } | null;
                } | null;
            };
        }>;
    };
};
type GqlGetBlockQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
type GqlGetBlockQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        header: {
            __typename: 'Header';
            height: string;
            time: any;
        };
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
        }>;
    } | null;
};
type GqlGetBlockWithTransactionsQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
type GqlGetBlockWithTransactionsQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
            rawPayload: string;
            gasPrice?: string | null;
            status?: {
                __typename: 'FailureStatus';
                time: any;
                reason: string;
                type: 'FailureStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
            } | {
                __typename: 'SqueezedOutStatus';
                type: 'SqueezedOutStatus';
            } | {
                __typename: 'SubmittedStatus';
                time: any;
                type: 'SubmittedStatus';
            } | {
                __typename: 'SuccessStatus';
                time: any;
                type: 'SuccessStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
                programState?: {
                    __typename: 'ProgramState';
                    returnType: GqlReturnType;
                    data: string;
                } | null;
            } | null;
        }>;
        header: {
            __typename: 'Header';
            height: string;
            time: any;
        };
    } | null;
};
type GqlGetBlocksQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetBlocksQuery = {
    __typename: 'Query';
    blocks: {
        __typename: 'BlockConnection';
        edges: Array<{
            __typename: 'BlockEdge';
            node: {
                __typename: 'Block';
                id: string;
                header: {
                    __typename: 'Header';
                    height: string;
                    time: any;
                };
                transactions: Array<{
                    __typename: 'Transaction';
                    id: string;
                }>;
            };
        }>;
    };
};
type GqlGetCoinQueryVariables = Exact<{
    coinId: Scalars['UtxoId'];
}>;
type GqlGetCoinQuery = {
    __typename: 'Query';
    coin?: {
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        blockCreated: string;
        coinStatus: GqlCoinStatus;
    } | null;
};
type GqlGetCoinsQueryVariables = Exact<{
    filter: GqlCoinFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetCoinsQuery = {
    __typename: 'Query';
    coins: {
        __typename: 'CoinConnection';
        edges: Array<{
            __typename: 'CoinEdge';
            node: {
                __typename: 'Coin';
                utxoId: string;
                owner: string;
                amount: string;
                assetId: string;
                maturity: string;
                blockCreated: string;
                coinStatus: GqlCoinStatus;
            };
        }>;
    };
};
type GqlGetResourcesToSpendQueryVariables = Exact<{
    owner: Scalars['Address'];
    queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;
    excludedIds?: InputMaybe<GqlExcludeInput>;
}>;
type GqlGetResourcesToSpendQuery = {
    __typename: 'Query';
    resourcesToSpend: Array<Array<{
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        blockCreated: string;
        coinStatus: GqlCoinStatus;
    } | {
        __typename: 'Message';
        amount: string;
        sender: string;
        recipient: string;
        data: string;
        nonce: string;
        daHeight: string;
        messageStatus: GqlMessageStatus;
    }>>;
};
type GqlGetContractQueryVariables = Exact<{
    contractId: Scalars['ContractId'];
}>;
type GqlGetContractQuery = {
    __typename: 'Query';
    contract?: {
        __typename: 'Contract';
        bytecode: string;
        id: string;
    } | null;
};
type GqlGetContractBalanceQueryVariables = Exact<{
    contract: Scalars['ContractId'];
    asset: Scalars['AssetId'];
}>;
type GqlGetContractBalanceQuery = {
    __typename: 'Query';
    contractBalance: {
        __typename: 'ContractBalance';
        contract: string;
        amount: string;
        assetId: string;
    };
};
type GqlGetBalanceQueryVariables = Exact<{
    owner: Scalars['Address'];
    assetId: Scalars['AssetId'];
}>;
type GqlGetBalanceQuery = {
    __typename: 'Query';
    balance: {
        __typename: 'Balance';
        owner: string;
        amount: string;
        assetId: string;
    };
};
type GqlGetBalancesQueryVariables = Exact<{
    filter: GqlBalanceFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetBalancesQuery = {
    __typename: 'Query';
    balances: {
        __typename: 'BalanceConnection';
        edges: Array<{
            __typename: 'BalanceEdge';
            node: {
                __typename: 'Balance';
                owner: string;
                amount: string;
                assetId: string;
            };
        }>;
    };
};
type GqlGetMessagesQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
type GqlGetMessagesQuery = {
    __typename: 'Query';
    messages: {
        __typename: 'MessageConnection';
        edges: Array<{
            __typename: 'MessageEdge';
            node: {
                __typename: 'Message';
                amount: string;
                sender: string;
                recipient: string;
                data: string;
                nonce: string;
                daHeight: string;
                messageStatus: GqlMessageStatus;
            };
        }>;
    };
};
type GqlGetMessageProofQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
    messageId: Scalars['MessageId'];
}>;
type GqlGetMessageProofQuery = {
    __typename: 'Query';
    messageProof?: {
        __typename: 'MessageProof';
        proofSet: Array<string>;
        proofIndex: string;
        sender: string;
        recipient: string;
        nonce: string;
        amount: string;
        data: string;
        signature: any;
        header: {
            __typename: 'Header';
            id: string;
            daHeight: string;
            transactionsCount: string;
            outputMessagesCount: string;
            transactionsRoot: string;
            outputMessagesRoot: string;
            height: string;
            prevRoot: string;
            time: any;
            applicationHash: string;
        };
    } | null;
};
type GqlDryRunMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
    utxoValidation?: InputMaybe<Scalars['Boolean']>;
}>;
type GqlDryRunMutation = {
    __typename: 'Mutation';
    dryRun: Array<{
        __typename: 'Receipt';
        data?: string | null;
        rawPayload: string;
    }>;
};
type GqlSubmitMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
}>;
type GqlSubmitMutation = {
    __typename: 'Mutation';
    submit: {
        __typename: 'Transaction';
        id: string;
    };
};
type GqlStartSessionMutationVariables = Exact<{
    [key: string]: never;
}>;
type GqlStartSessionMutation = {
    __typename: 'Mutation';
    startSession: string;
};
type GqlEndSessionMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
type GqlEndSessionMutation = {
    __typename: 'Mutation';
    endSession: boolean;
};
type GqlExecuteMutationVariables = Exact<{
    sessionId: Scalars['ID'];
    op: Scalars['String'];
}>;
type GqlExecuteMutation = {
    __typename: 'Mutation';
    execute: boolean;
};
type GqlResetMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
type GqlResetMutation = {
    __typename: 'Mutation';
    reset: boolean;
};
type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    getVersion(variables?: GqlGetVersionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetVersionQuery>;
    getInfo(variables?: GqlGetInfoQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetInfoQuery>;
    getChain(variables?: GqlGetChainQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetChainQuery>;
    getTransaction(variables: GqlGetTransactionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionQuery>;
    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionWithReceiptsQuery>;
    getTransactions(variables?: GqlGetTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsQuery>;
    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsByOwnerQuery>;
    getBlock(variables?: GqlGetBlockQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockQuery>;
    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockWithTransactionsQuery>;
    getBlocks(variables?: GqlGetBlocksQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlocksQuery>;
    getCoin(variables: GqlGetCoinQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinQuery>;
    getCoins(variables: GqlGetCoinsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsQuery>;
    getResourcesToSpend(variables: GqlGetResourcesToSpendQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetResourcesToSpendQuery>;
    getContract(variables: GqlGetContractQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetContractQuery>;
    getContractBalance(variables: GqlGetContractBalanceQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetContractBalanceQuery>;
    getBalance(variables: GqlGetBalanceQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalanceQuery>;
    getBalances(variables: GqlGetBalancesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalancesQuery>;
    getMessages(variables: GqlGetMessagesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetMessagesQuery>;
    getMessageProof(variables: GqlGetMessageProofQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetMessageProofQuery>;
    dryRun(variables: GqlDryRunMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlDryRunMutation>;
    submit(variables: GqlSubmitMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlSubmitMutation>;
    startSession(variables?: GqlStartSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlStartSessionMutation>;
    endSession(variables: GqlEndSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlEndSessionMutation>;
    execute(variables: GqlExecuteMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlExecuteMutation>;
    reset(variables: GqlResetMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlResetMutation>;
};

/**
 * A Fuel coin
 */
type Coin = {
    id: string;
    assetId: string;
    amount: BN;
    owner: AbstractAddress;
    status: GqlCoinStatus;
    maturity: number;
    blockCreated: BN;
};

/**
 * A Fuel message
 */
type Message = {
    sender: AbstractAddress;
    recipient: AbstractAddress;
    nonce: BN;
    amount: BN;
    data: BytesLike;
    status: GqlMessageStatus;
    daHeight: BN;
};
/**
 * Message Proof
 */
type MessageProof = {
    proofSet: Array<string>;
    proofIndex: BN;
    sender: AbstractAddress;
    recipient: AbstractAddress;
    nonce: string;
    amount: BN;
    data: string;
    signature: string;
    header: {
        id: string;
        daHeight: BN;
        transactionsCount: BN;
        outputMessagesCount: BN;
        transactionsRoot: string;
        outputMessagesRoot: string;
        height: BN;
        prevRoot: string;
        time: string;
        applicationHash: string;
    };
};

type RawCoin = {
    utxoId: string;
    owner: string;
    amount: string;
    assetId: string;
    maturity: string;
    coinStatus: GqlCoinStatus;
    blockCreated: string;
};
type RawMessage = {
    amount: string;
    sender: string;
    recipient: string;
    data: string;
    nonce: string;
    messageStatus: GqlMessageStatus;
    daHeight: string;
};
type RawResource = RawCoin | RawMessage;
type Resource = Coin | Message;
type Resources = GqlGetResourcesToSpendQuery['resourcesToSpend'];
type ExcludeResourcesOption = {
    utxos?: BytesLike[];
    messages?: BytesLike[];
};
declare const isRawCoin: (resource: RawResource) => resource is RawCoin;
declare const isRawMessage: (resource: RawResource) => resource is RawMessage;
declare const isCoin: (resource: Resource) => resource is Coin;
declare const isMessage: (resource: Resource) => resource is Message;

type CoinTransactionRequestInput = {
    type: InputType.Coin;
    /** UTXO ID */
    id: BytesLike;
    /** Owning address or script hash */
    owner: BytesLike;
    /** Amount of coins */
    amount: BigNumberish;
    /** Asset ID of the coins */
    assetId: BytesLike;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Index of witness that authorizes spending the coin */
    witnessIndex: number;
    /** UTXO being spent must have been created at least this many blocks ago */
    maturity?: number;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
type MessageTransactionRequestInput = {
    type: InputType.Message;
    /** Amount of coins */
    amount: BigNumberish;
    /** Address of sender */
    sender: BytesLike;
    /** Address of sender */
    recipient: BytesLike;
    /** Index of witness that authorizes the message */
    witnessIndex: number;
    /** data of message */
    data: BytesLike;
    /** Unique nonce of message */
    nonce: BigNumberish;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
type ContractTransactionRequestInput = {
    type: InputType.Contract;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Contract ID */
    contractId: BytesLike;
};
type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput | MessageTransactionRequestInput;
declare const inputify: (value: TransactionRequestInput) => Input;

type CoinTransactionRequestOutput = {
    type: OutputType.Coin;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Amount of coins to send */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
type ContractTransactionRequestOutput = {
    type: OutputType.Contract;
    /** Index of input contract */
    inputIndex: number;
};
type MessageTransactionRequestOutput = {
    type: OutputType.Message;
    /** Receiving address */
    recipient: BytesLike;
    /** Amount of coins sent with message */
    amount: BigNumberish;
};
type ChangeTransactionRequestOutput = {
    type: OutputType.Change;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Asset ID of coins */
    assetId: BytesLike;
};
type VariableTransactionRequestOutput = {
    type: OutputType.Variable;
};
type ContractCreatedTransactionRequestOutput = {
    type: OutputType.ContractCreated;
    /** Contract ID */
    contractId: BytesLike;
    /** State Root */
    stateRoot: BytesLike;
};
type TransactionRequestOutput = CoinTransactionRequestOutput | ContractTransactionRequestOutput | MessageTransactionRequestOutput | ChangeTransactionRequestOutput | VariableTransactionRequestOutput | ContractCreatedTransactionRequestOutput;
declare const outputify: (value: TransactionRequestOutput) => Output;

type TransactionRequestStorageSlot = {
    /** Key */
    key: BytesLike;
    /** Value */
    value: BytesLike;
} | [key: BytesLike, value: BytesLike];

type TransactionRequestWitness = BytesLike;

declare const returnZeroScript: AbstractScriptRequest<void>;
declare const withdrawScript: AbstractScriptRequest<void>;
interface BaseTransactionRequestLike {
    /** Gas price for transaction */
    gasPrice?: BigNumberish;
    /** Gas limit for transaction */
    gasLimit?: BigNumberish;
    /** Block until which tx cannot be included */
    maturity?: number;
    /** List of inputs */
    inputs?: TransactionRequestInput[];
    /** List of outputs */
    outputs?: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses?: TransactionRequestWitness[];
}
declare class ChangeOutputCollisionError extends Error {
    name: string;
    message: string;
}
declare class NoWitnessAtIndexError extends Error {
    readonly index: number;
    name: string;
    constructor(index: number);
}
declare class NoWitnessByOwnerError extends Error {
    readonly owner: AbstractAddress;
    name: string;
    constructor(owner: AbstractAddress);
}
declare abstract class BaseTransactionRequest implements BaseTransactionRequestLike {
    /** Type of the transaction */
    abstract type: TransactionType;
    /** Gas price for transaction */
    gasPrice: BN;
    /** Gas limit for transaction */
    gasLimit: BN;
    /** Block until which tx cannot be included */
    maturity: number;
    /** List of inputs */
    inputs: TransactionRequestInput[];
    /** List of outputs */
    outputs: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses: TransactionRequestWitness[];
    constructor({ gasPrice, gasLimit, maturity, inputs, outputs, witnesses, }?: BaseTransactionRequestLike);
    protected getBaseTransaction(): Pick<TransactionScript | TransactionCreate, keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'>;
    abstract toTransaction(): TransactionCreate | TransactionScript;
    toTransactionBytes(): Uint8Array;
    /**
     * Pushes an input to the list without any side effects and returns the index
     */
    protected pushInput(input: TransactionRequestInput): number;
    /**
     * Pushes an output to the list without any side effects and returns the index
     */
    protected pushOutput(output: TransactionRequestOutput): number;
    /**
     * Creates an empty witness without any side effects and returns the index
     */
    protected createWitness(): number;
    updateWitnessByOwner(address: AbstractAddress, signature: BytesLike): void;
    /**
     * Updates an existing witness without any side effects
     */
    updateWitness(index: number, witness: TransactionRequestWitness): void;
    getCoinInputs(): CoinTransactionRequestInput[];
    getCoinOutputs(): CoinTransactionRequestOutput[];
    getChangeOutputs(): ChangeTransactionRequestOutput[];
    /**
     * Returns the witnessIndex of the found CoinInput
     */
    getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null;
    /**
     * Updates the witness for the given CoinInput owner
     */
    updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike): void;
    /**
     * Converts the given Resource to a ResourceInput with the appropriate witnessIndex and pushes it
     */
    addResource(resource: Resource): void;
    addResources(resources: ReadonlyArray<Resource>): void;
    addCoinOutput(
    /** Address of the destination */
    to: AddressLike, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike): void;
    addCoinOutputs(
    /** Address of the destination */
    to: AddressLike, 
    /** Quantities of coins */
    quantities: CoinQuantityLike[]): void;
    byteSize(): number;
    chargeableByteSize(): BN;
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * Note: this is required even gasPrice = 0
     */
    calculateFee(): CoinQuantity;
    toJSON(): any;
}
interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {
    /** Script to execute */
    script?: BytesLike;
    /** Script input data (parameters) */
    scriptData?: BytesLike;
}
declare class ScriptTransactionRequest extends BaseTransactionRequest {
    static from(obj: ScriptTransactionRequestLike): ScriptTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Script;
    /** Script to execute */
    script: Uint8Array;
    /** Script input data (parameters) */
    scriptData: Uint8Array;
    /** determined bytes offset for start of script data */
    bytesOffset: number | undefined;
    constructor({ script, scriptData, ...rest }?: ScriptTransactionRequestLike);
    toTransaction(): TransactionScript;
    getContractInputs(): ContractTransactionRequestInput[];
    getContractOutputs(): ContractTransactionRequestOutput[];
    getVariableOutputs(): VariableTransactionRequestOutput[];
    setScript<T>(script: AbstractScriptRequest<T>, data: T): void;
    addVariableOutputs(numberOfVariables?: number): number;
    addMessageOutputs(numberOfMessages?: number): number;
    addContract(contract: ContractIdLike): void;
}
interface CreateTransactionRequestLike extends BaseTransactionRequestLike {
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex?: number;
    /** Salt */
    salt?: BytesLike;
    /** List of storage slots to initialize */
    storageSlots?: TransactionRequestStorageSlot[];
}
declare class CreateTransactionRequest extends BaseTransactionRequest {
    static from(obj: CreateTransactionRequestLike): CreateTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex: number;
    /** Salt */
    salt: string;
    /** List of storage slots to initialize */
    storageSlots: TransactionRequestStorageSlot[];
    constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }?: CreateTransactionRequestLike);
    toTransaction(): TransactionCreate;
    getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[];
    addContractCreatedOutput(
    /** Contract ID */
    contractId: BytesLike, 
    /** State Root */
    stateRoot: BytesLike): void;
}
type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;
type TransactionRequestLike = ({
    type: TransactionType.Script;
} & ScriptTransactionRequestLike) | ({
    type: TransactionType.Create;
} & CreateTransactionRequestLike);
declare const transactionRequestify: (obj: TransactionRequestLike) => TransactionRequest;

type TransactionResultCallReceipt = ReceiptCall;
type TransactionResultReturnReceipt = ReceiptReturn;
type TransactionResultReturnDataReceipt = ReceiptReturnData & {
    data: string;
};
type TransactionResultPanicReceipt = ReceiptPanic;
type TransactionResultRevertReceipt = ReceiptRevert;
type TransactionResultLogReceipt = ReceiptLog;
type TransactionResultLogDataReceipt = ReceiptLogData & {
    data: string;
};
type TransactionResultTransferReceipt = ReceiptTransfer;
type TransactionResultTransferOutReceipt = ReceiptTransferOut;
type TransactionResultScriptResultReceipt = ReceiptScriptResult;
type TransactionResultMessageOutReceipt = ReceiptMessageOut;
type TransactionResultReceipt = TransactionResultCallReceipt | TransactionResultReturnReceipt | TransactionResultReturnDataReceipt | TransactionResultPanicReceipt | TransactionResultRevertReceipt | TransactionResultLogReceipt | TransactionResultLogDataReceipt | TransactionResultTransferReceipt | TransactionResultTransferOutReceipt | TransactionResultScriptResultReceipt | TransactionResultMessageOutReceipt;
type TransactionResult<TStatus extends 'success' | 'failure', TTransactionType = void> = {
    status: TStatus extends 'success' ? {
        type: 'success';
        programState: any;
    } : {
        type: 'failure';
        reason: any;
    };
    /** Receipts produced during the execution of the transaction */
    receipts: TransactionResultReceipt[];
    transactionId: string;
    blockId: any;
    time: any;
    gasUsed: BN;
    fee: BN;
    transaction: Transaction<TTransactionType>;
};
declare class TransactionResponse {
    /** Transaction ID */
    id: string;
    /** Current provider */
    provider: Provider;
    /** Gas used on the transaction */
    gasUsed: BN;
    /** Number off attempts to get the committed tx */
    attempts: number;
    constructor(id: string, provider: Provider);
    fetch(): Promise<GqlGetTransactionWithReceiptsQuery['transaction']>;
    decodeTransaction<TTransactionType = void>(transactionWithReceipts: NonNullable<GqlGetTransactionWithReceiptsQuery['transaction']>): Transaction<TTransactionType>;
    /** Waits for transaction to succeed or fail and returns the result */
    waitForResult<TTransactionType = void>(): Promise<TransactionResult<any, TTransactionType>>;
    /** Waits for transaction to succeed and returns the result */
    wait<TTransactionType = void>(): Promise<TransactionResult<'success', TTransactionType>>;
}

type CallResult = {
    receipts: TransactionResultReceipt[];
};
/**
 * A Fuel block
 */
type Block = {
    id: string;
    height: BN;
    time: string;
    transactionIds: string[];
};
/**
 * Deployed Contract bytecode and contract id
 */
type ContractResult = {
    id: string;
    bytecode: string;
};
/**
 * Chain information
 */
type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    peerCount: number;
    consensusParameters: {
        contractMaxSize: BN;
        maxInputs: BN;
        maxOutputs: BN;
        maxWitnesses: BN;
        maxGasPerTx: BN;
        maxScriptLength: BN;
        maxScriptDataLength: BN;
        maxStorageSlots: BN;
        maxPredicateLength: BN;
        maxPredicateDataLength: BN;
        gasPriceFactor: BN;
        gasPerByte: BN;
        maxMessageDataLength: BN;
    };
    latestBlock: {
        id: string;
        height: BN;
        time: string;
        transactions: Array<{
            id: string;
        }>;
    };
};
/**
 * Node information
 */
type NodeInfo = {
    minGasPrice: BN;
    nodeVersion: string;
};
type TransactionCost = {
    minGasPrice: BN;
    gasPrice: BN;
    gasUsed: BN;
    fee: BN;
};
/**
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
type BuildPredicateOptions = {
    fundTransaction?: boolean;
} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;
type FetchRequestOptions = {
    method: 'POST';
    headers: {
        [key: string]: string;
    };
    body: string;
};
type ProviderOptions = {
    fetch?: (url: string, options: FetchRequestOptions) => Promise<any>;
};
/**
 * Provider Call transaction params
 */
type ProviderCallParams = {
    utxoValidation?: boolean;
};
/**
 * A provider for connecting to a Fuel node
 */
declare class Provider {
    /** GraphQL endpoint of the Fuel node */
    url: string;
    options: ProviderOptions;
    operations: ReturnType<typeof getSdk>;
    constructor(
    /** GraphQL endpoint of the Fuel node */
    url: string, options?: ProviderOptions);
    /**
     * Create GraphQL client and set operations
     */
    private createOperations;
    /**
     * Connect provider to a different Fuel node url
     */
    connect(url: string): void;
    /**
     * Returns the version of the connected Fuel node
     */
    getVersion(): Promise<string>;
    /**
     * Returns the network configuration of the connected Fuel node
     */
    getNetwork(): Promise<Network>;
    /**
     * Returns the current block number
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns node information
     */
    getNodeInfo(): Promise<NodeInfo>;
    /**
     * Returns chain information
     */
    getChain(): Promise<ChainInfo>;
    /**
     * Submits a transaction to the chain to be executed
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    call(transactionRequestLike: TransactionRequestLike, { utxoValidation }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Will dryRun a transaction and check for missing VariableOutputs
     *
     * If there are missing VariableOutputs
     * `addVariableOutputs` is called on the transaction.
     * This process is done at most 10 times
     */
    addMissingVariables(transactionRequest: TransactionRequest): Promise<void>;
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    simulate(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, tolerance?: number): Promise<TransactionCost>;
    /**
     * Returns coins for the given owner
     */
    getCoins(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId?: BytesLike, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Coin[]>;
    /**
     * Returns resources for the given owner satisfying the spend query
     */
    getResourcesToSpend(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The quantities to get */
    quantities: CoinQuantityLike[], 
    /** IDs of excluded resources from the selection. */
    excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Returns block matching the given ID or type
     */
    getBlock(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns block matching the given ID or type, including transaction data
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID
     */
    getTransaction<TTransactionType = void>(transactionId: string): Promise<Transaction<TTransactionType> | null>;
    /**
     * Get deployed contract with the given ID
     *
     * @returns contract bytecode and contract id
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given contract for the given asset ID
     */
    getContractBalance(
    /** The contract ID to get the balance for */
    contractId: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns the balance for the given owner for the given asset ID
     */
    getBalance(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner
     */
    getBalances(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<CoinQuantity[]>;
    /**
     * Returns message for the given address
     */
    getMessages(
    /** The address to get message from */
    address: AbstractAddress, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Message[]>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt
     */
    getMessageProof(
    /** The transaction to get message from */
    transactionId: string, 
    /** The message id from MessageOut receipt */
    messageId: string): Promise<MessageProof | null>;
}

declare function getDecodedLogs<T = unknown>(receipts: Array<TransactionResultReceipt>, abiInterface: Interface): T[];

declare const getReceiptsWithMissingData: (receipts: Array<TransactionResultReceipt>) => {
    missingOutputVariables: Array<ReceiptRevert>;
    missingOutputContractIds: Array<ReceiptPanic>;
};

declare const calculatePriceWithFactor: (gasUsed: BN, gasPrice: BN, priceFactor: BN) => BN;
declare const getGasUsedFromReceipts: (receipts: Array<TransactionResultReceipt>) => BN;
declare const calculateTransactionFee: ({ receipts, gasPrice, margin, }: {
    receipts: TransactionResultReceipt[];
    gasPrice: BN;
    margin?: number | undefined;
}) => {
    gasUsed: BN;
    fee: BN;
};

/**
 * Builds a block explorer url based on and the given path, block explorer URL and provider URL
 */
declare const buildBlockExplorerUrl: (options?: {
    blockExplorerUrl?: string;
    path?: string;
    providerUrl?: string;
    address?: string;
    txId?: string;
    blockNumber?: number;
}) => string;

/**
 * Stringify Transaction to a JSON object
 * compatible with the Transaction class constructor.
 */
declare function normalizeJSON(root: any): any;

declare function sleep(time: number): Promise<unknown>;

export { Block, BuildPredicateOptions, CallResult, ChainInfo, ChangeOutputCollisionError, ChangeTransactionRequestOutput, Coin, CoinQuantity, CoinQuantityLike, GqlCoinStatus as CoinStatus, CoinTransactionRequestInput, CoinTransactionRequestOutput, ContractCreatedTransactionRequestOutput, ContractResult, ContractTransactionRequestInput, ContractTransactionRequestOutput, CreateTransactionRequest, CreateTransactionRequestLike, CursorPaginationArgs, ExcludeResourcesOption, FetchRequestOptions, Message, MessageProof, GqlMessageStatus as MessageStatus, MessageTransactionRequestInput, MessageTransactionRequestOutput, NoWitnessAtIndexError, NoWitnessByOwnerError, NodeInfo, Provider, ProviderCallParams, ProviderOptions, RawCoin, RawMessage, RawResource, Resource, Resources, ScriptTransactionRequest, ScriptTransactionRequestLike, TransactionCost, TransactionRequest, TransactionRequestInput, TransactionRequestLike, TransactionRequestOutput, TransactionResponse, TransactionResult, TransactionResultCallReceipt, TransactionResultLogDataReceipt, TransactionResultLogReceipt, TransactionResultMessageOutReceipt, TransactionResultPanicReceipt, TransactionResultReceipt, TransactionResultReturnDataReceipt, TransactionResultReturnReceipt, TransactionResultRevertReceipt, TransactionResultScriptResultReceipt, TransactionResultTransferOutReceipt, TransactionResultTransferReceipt, VariableTransactionRequestOutput, buildBlockExplorerUrl, calculatePriceWithFactor, calculateTransactionFee, coinQuantityfy, getDecodedLogs, getGasUsedFromReceipts, getReceiptsWithMissingData, inputify, isCoin, isMessage, isRawCoin, isRawMessage, normalizeJSON, outputify, returnZeroScript, sleep, transactionRequestify, withdrawScript };
