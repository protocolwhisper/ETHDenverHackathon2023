import { BytesLike } from '@ethersproject/bytes';
import * as _fuel_ts_providers from '@fuel-ts/providers';
import { Provider, CoinQuantityLike, ExcludeResourcesOption, Resource, Coin, Message, CoinQuantity, TransactionRequest, TransactionRequestLike, TransactionResponse, CallResult } from '@fuel-ts/providers';
import { AbstractAccount, AbstractAddress } from '@fuel-ts/interfaces';
import { BN, BigNumberish } from '@fuel-ts/math';
import { Signer } from '@fuel-ts/signer';

/**
 * Account
 */
declare class Account extends AbstractAccount {
    readonly address: AbstractAddress;
    provider: Provider;
    constructor(address: string | AbstractAddress, provider?: string | Provider);
    /**
     * Change provider connection
     */
    connect(provider: string | Provider): Provider;
    /**
     * Returns resources satisfying the spend query.
     */
    getResourcesToSpend(quantities: CoinQuantityLike[] /** IDs of coins to exclude */, excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Gets coins owned by the wallet address.
     */
    getCoins(assetId?: BytesLike): Promise<Coin[]>;
    /**
     * Gets messages owned by the wallet address.
     */
    getMessages(): Promise<Message[]>;
    /**
     * Gets balance for the given asset.
     */
    getBalance(assetId?: BytesLike): Promise<BN>;
    /**
     * Gets balances.
     */
    getBalances(): Promise<CoinQuantity[]>;
    /**
     * Adds resources to the transaction enough to fund it.
     */
    fund<T extends TransactionRequest>(request: T): Promise<void>;
    /**
     * Returns coins satisfying the spend query.
     */
    transfer(
    /** Address of the destination */
    destination: AbstractAddress, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike, 
    /** Tx Params */
    txParams?: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>): Promise<TransactionResponse>;
    /**
     * Withdraws an amount of the base asset to the base chain.
     */
    withdrawToBaseLayer(
    /** Address of the recipient on the base chain */
    recipient: AbstractAddress, 
    /** Amount of base asset */
    amount: BigNumberish, 
    /** Tx Params */
    txParams?: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns TransactionResponse
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send a call it to the network using `provider.call`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns CallResult
     */
    simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
}

/**
 * BaseWalletUnlocked
 */
declare class BaseWalletUnlocked extends Account {
    static defaultPath: string;
    provider: Provider;
    signer: () => Signer;
    constructor(privateKey: BytesLike, provider?: string | Provider);
    get privateKey(): string;
    get publicKey(): string;
    /**
     * Sign message with wallet instance privateKey
     *
     * @param message - Message
     * @returns Promise<string> - Signature a ECDSA 64 bytes
     */
    signMessage(message: string): Promise<string>;
    /**
     * Sign transaction with wallet instance privateKey
     *
     * @param transactionRequestLike - TransactionRequestLike
     * @returns string - Signature a ECDSA 64 bytes
     */
    signTransaction(transactionRequestLike: TransactionRequestLike): Promise<string>;
    populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike): Promise<_fuel_ts_providers.TransactionRequest>;
    /**
     * Populates witnesses signature and send it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns TransactionResponse
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send a call it to the network using `provider.call`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns CallResult
     */
    simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
}

interface GenerateOptions {
    /** Additional entropy for the random bytes */
    entropy?: BytesLike;
    provider?: string | Provider;
}

/**
 * WalletLocked
 */
declare class WalletLocked extends Account {
    unlock(privateKey: BytesLike): WalletUnlocked;
}
/**
 * WalletUnlocked
 */
declare class WalletUnlocked extends BaseWalletUnlocked {
    lock(): WalletLocked;
    /**
     * Generate a new Wallet Unlocked with a random keyPair
     *
     * @param options - GenerateOptions
     * @returns wallet - Wallet instance
     */
    static generate(generateOptions?: GenerateOptions): WalletUnlocked;
    /**
     * Create Wallet Unlocked from a seed
     */
    static fromSeed(seed: string, path?: string, provider?: Provider): WalletUnlocked;
    /**
     * Create Wallet Unlocked from mnemonic phrase
     */
    static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike, provider?: Provider): WalletUnlocked;
    /**
     * Create Wallet Unlocked from extended key
     */
    static fromExtendedKey(extendedKey: string, provider?: Provider): WalletUnlocked;
}

export { Account as A, BaseWalletUnlocked as B, WalletLocked as W, WalletUnlocked as a };
