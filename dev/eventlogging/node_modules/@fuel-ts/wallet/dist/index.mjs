import{hashMessage as N,hashTransaction as W}from"@fuel-ts/hasher";import{transactionRequestify as R}from"@fuel-ts/providers";import{Signer as z}from"@fuel-ts/signer";import{arrayify as T,hexlify as A}from"@ethersproject/bytes";import{Address as B}from"@fuel-ts/address";import{NativeAssetId as L}from"@fuel-ts/constants";import{AbstractAccount as E}from"@fuel-ts/interfaces";import{bn as K}from"@fuel-ts/math";import{withdrawScript as M,ScriptTransactionRequest as S,Provider as C,transactionRequestify as x}from"@fuel-ts/providers";import{MAX_GAS_PER_TX as k}from"@fuel-ts/transactions";var p="http://127.0.0.1:4000/graphql";var u=class extends E{constructor(e,t=p){super();this.provider=this.connect(t),this.address=B.fromDynamicInput(e)}connect(e){return typeof e=="string"?this.provider?this.provider.connect(e):this.provider=new C(e):this.provider=e,this.provider}async getResourcesToSpend(e,t){return this.provider.getResourcesToSpend(this.address,e,t)}async getCoins(e){let t=[],i;for(;;){let n=await this.provider.getCoins(this.address,e,{first:9999,after:i});if(t.push(...n),!(n.length>=9999))break;throw new Error(`Wallets with more than ${9999} coins are not yet supported`)}return t}async getMessages(){let e=[],s;for(;;){let i=await this.provider.getMessages(this.address,{first:9999,after:s});if(e.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} messages are not yet supported`)}return e}async getBalance(e=L){return await this.provider.getBalance(this.address,e)}async getBalances(){let e=[],s;for(;;){let i=await this.provider.getBalances(this.address,{first:9999,after:s});if(e.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} balances are not yet supported`)}return e}async fund(e){let t=e.calculateFee(),s=await this.getResourcesToSpend([t]);e.addResources(s)}async transfer(e,t,s=L,i={}){let n={gasLimit:k,...i},o=new S(n);o.addCoinOutput(e,t,s);let d=o.calculateFee(),c=[];d.assetId===A(s)?(d.amount=d.amount.add(t),c=[d]):c=[[t,s],d];let g=await this.getResourcesToSpend(c);return o.addResources(g),this.sendTransaction(o)}async withdrawToBaseLayer(e,t,s={}){let i=T("0x".concat(e.toHexString().substring(2).padStart(64,"0"))),n=T("0x".concat(K(t).toHex().substring(2).padStart(16,"0"))),d={script:new Uint8Array([...T(M.bytes),...i,...n]),gasLimit:k,...s},c=new S(d);c.addMessageOutputs();let g=c.calculateFee(),w=[];g.amount=g.amount.add(t),w=[g];let q=await this.getResourcesToSpend(w);return c.addResources(q),this.sendTransaction(c)}async sendTransaction(e){let t=x(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(t)}async simulateTransaction(e){let t=x(e);return await this.provider.addMissingVariables(t),this.provider.simulate(t)}};var y=class extends u{constructor(e,t=p){let s=new z(e);super(s.address,t);this.signer=()=>s,this.provider=this.connect(t)}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}async signMessage(e){return this.signer().sign(N(e))}async signTransaction(e){let t=R(e),s=W(t);return this.signer().sign(s)}async populateTransactionWitnessesSignature(e){let t=R(e),s=await this.signTransaction(t);return t.updateWitnessByOwner(this.address,s),t}async sendTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(t))}async simulateTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.call(await this.populateTransactionWitnessesSignature(t),{utxoValidation:!0})}};y.defaultPath="m/44'/1179993420'/0'/0/0";import{HDWallet as P}from"@fuel-ts/hdwallet";import{Mnemonic as F}from"@fuel-ts/mnemonic";import{Signer as b}from"@fuel-ts/signer";var l=class extends u{unlock(r){return new a(r,this.provider)}},a=class extends y{lock(){return this.signer=()=>new b("0x00"),new l(this.address,this.provider)}static generate(r){let e=b.generatePrivateKey(r==null?void 0:r.entropy);return new a(e,r==null?void 0:r.provider)}static fromSeed(r,e,t){let i=P.fromSeed(r).derivePath(e||a.defaultPath);return new a(i.privateKey,t)}static fromMnemonic(r,e,t,s){let i=F.mnemonicToSeed(r,t),o=P.fromSeed(i).derivePath(e||a.defaultPath);return new a(o.privateKey,s)}static fromExtendedKey(r,e){let t=P.fromExtendedKey(r);return new a(t.privateKey,e)}};var m=class{static fromAddress(r,e=p){return new l(r,e)}static fromPrivateKey(r,e=p){return new a(r,e)}};m.generate=a.generate,m.fromSeed=a.fromSeed,m.fromMnemonic=a.fromMnemonic,m.fromExtendedKey=a.fromExtendedKey;export{u as Account,y as BaseWalletUnlocked,m as Wallet,l as WalletLocked,a as WalletUnlocked};
//# sourceMappingURL=index.mjs.map