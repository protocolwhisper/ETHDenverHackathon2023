import { BytesLike } from '@ethersproject/bytes';
import { FunctionFragment, Interface, JsonAbi, JsonFlatAbi } from '@fuel-ts/abi-coder';
import { AbstractProgram, AbstractContract, AbstractAddress } from '@fuel-ts/interfaces';
import * as _fuel_ts_math from '@fuel-ts/math';
import { BN, BigNumberish } from '@fuel-ts/math';
import * as _fuel_ts_providers from '@fuel-ts/providers';
import { CallResult, TransactionResultReceipt, TransactionResponse, TransactionResult, ScriptTransactionRequest, CoinQuantity, TransactionRequest, CoinQuantityLike, Provider, TransactionResultScriptResultReceipt, TransactionResultReturnReceipt, TransactionResultReturnDataReceipt, TransactionResultRevertReceipt } from '@fuel-ts/providers';
import { Account } from '@fuel-ts/wallet';

declare class InvocationResult<T = any> {
    readonly functionScopes: Array<InvocationScopeLike>;
    readonly isMultiCall: boolean;
    readonly gasUsed: BN;
    readonly value: T;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean);
    private getFirstCallConfig;
    protected getDecodedValue(callResult: CallResult): T;
    protected getDecodedLogs(receipts: Array<TransactionResultReceipt>): unknown[];
}
declare class FunctionInvocationResult<T = any, TTransactionType = void> extends InvocationResult<T> {
    readonly transactionId: string;
    readonly transactionResponse: TransactionResponse;
    readonly transactionResult: TransactionResult<any, TTransactionType>;
    readonly program: AbstractProgram;
    readonly logs: Array<any>;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, transactionResponse: TransactionResponse, transactionResult: TransactionResult<any, TTransactionType>, program: AbstractProgram, isMultiCall: boolean);
    static build<T, TTransactionType = void>(funcScope: InvocationScopeLike | Array<InvocationScopeLike>, transactionResponse: TransactionResponse, isMultiCall: boolean, program: AbstractProgram): Promise<FunctionInvocationResult<T, TTransactionType>>;
}
declare class InvocationCallResult<T = any> extends InvocationResult<T> {
    readonly callResult: CallResult;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean);
    static build<T>(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean): Promise<InvocationCallResult<T>>;
}

declare class BaseInvocationScope<TReturn = any> {
    transactionRequest: ScriptTransactionRequest;
    protected program: AbstractProgram;
    protected functionInvocationScopes: Array<InvocationScopeLike>;
    protected txParameters?: TxParams;
    protected requiredCoins: CoinQuantity[];
    protected isMultiCall: boolean;
    constructor(program: AbstractProgram, isMultiCall: boolean);
    protected get calls(): ContractCall[];
    protected static getCallOptions(options?: CallOptions): {
        fundTransaction: boolean;
    };
    protected updateScriptRequest(): void;
    protected getRequiredCoins(): Array<CoinQuantity>;
    protected updateRequiredCoins(): void;
    protected addCall(funcScope: InvocationScopeLike): this;
    protected addCalls(funcScopes: Array<InvocationScopeLike>): this;
    protected prepareTransaction(options?: CallOptions): Promise<void>;
    protected checkGasLimitTotal(): void;
    /**
     * Run a valid transaction in dryRun mode and returns useful details about
     * gasUsed, gasPrice and transaction estimate fee in native coins.
     */
    getTransactionCost(options?: TransactionCostOptions): Promise<_fuel_ts_providers.TransactionCost>;
    /**
     * Add to the transaction scope the required amount of unspent UTXO's.
     *
     * Required Amount = forward coins + transfers + gas fee.
     */
    fundWithRequiredCoins(): Promise<this>;
    txParams(txParams: TxParams): this;
    addContracts(contracts: Array<AbstractContract>): this;
    /**
     * Prepare transaction request object, adding Inputs, Outputs, coins, check gas costs
     * and transaction validity.
     *
     * It's possible to get the transaction without adding coins, by passing `fundTransaction`
     * as false.
     */
    getTransactionRequest(options?: CallOptions): Promise<TransactionRequest>;
    /**
     * Submits a transaction to the blockchain.
     *
     * This is a final action and will spend the coins and change the state of the contract.
     * It also means that invalid transactions will throw an error, and consume gas. To avoid this
     * running invalid tx and consuming gas try to `simulate` first when possible.
     */
    call<T = TReturn>(options?: CallOptions): Promise<FunctionInvocationResult<T>>;
    /**
     * Run a valid transaction and return the result without change the chain state.
     * This means, all signatures are validated but no UTXO is spent.
     *
     * This method is useful for validate propose to avoid spending coins on invalid TXs, also
     * to estimate the amount of gas that will be required to run the transaction.
     */
    simulate<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
    /**
     * Executes a transaction in dry run mode, without UTXO validations.
     *
     * A transaction in dry run mode can't change the state of the blockchain. It can be useful to access readonly
     * methods or just ust get.
     * The UTXO validation disable in this case, enables to send invalid inputs to emulate different conditions, of a
     * transaction
     */
    dryRun<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
    /**
     * Executes a readonly contract method call.
     *
     * Under the hood it uses the `dryRun` method but don't fund the transaction
     * with coins by default, for emulating executions with forward coins use `dryRun`
     * or pass the options.fundTransaction as true
     */
    get<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
}

declare class FunctionInvocationScope<TArgs extends Array<any> = Array<any>, TReturn = any> extends BaseInvocationScope<TReturn> {
    protected func: FunctionFragment;
    private callParameters?;
    private forward?;
    protected args: TArgs;
    constructor(program: AbstractProgram, func: FunctionFragment, args: TArgs);
    getCallConfig(): CallConfig<TArgs>;
    setArguments(...args: TArgs): this;
    callParams(callParams: CallParams): this;
}

type ContractCall = {
    contractId: AbstractAddress;
    data: BytesLike;
    amount?: BigNumberish;
    assetId?: BytesLike;
    gas?: BigNumberish;
};
type CallParams = Partial<{
    forward: CoinQuantityLike;
    gasLimit: BigNumberish;
}>;
type TxParams = Partial<{
    gasPrice: BigNumberish;
    gasLimit: BigNumberish;
    variableOutputs: number;
}>;
type CallOptions = Partial<{
    fundTransaction: boolean;
}>;
type CallConfig<T = unknown> = {
    func: FunctionFragment;
    program: AbstractProgram;
    callParameters?: CallParams;
    txParameters?: TxParams;
    forward?: CoinQuantity;
    args: T;
    bytesOffset: number;
};
type InvokeFunction<TArgs extends Array<any> = Array<any>, TReturn = any> = (...args: TArgs) => FunctionInvocationScope<TArgs, TReturn>;
interface InvokeFunctions {
    [key: string]: InvokeFunction;
}
type InvocationScopeLike<T = unknown> = {
    getCallConfig(): CallConfig<T>;
};
type TransactionCostOptions = Partial<{
    fundTransaction: boolean;
    gasPrice: BigNumberish;
    tolerance: number;
}>;

declare const getDocs: (status: TransactionResult<'failure'>['status']) => {
    doc: string;
    reason: string;
};
/**
 * Generic assert function to avoid undesirable errors
 */
declare function assert(condition: unknown, message: string): asserts condition;

declare class ScriptResultDecoderError extends Error {
    logs: any[];
    constructor(result: TransactionResult<'failure'>, message: string, logs: Array<any>);
}

declare class MultiCallInvocationScope<TReturn = any> extends BaseInvocationScope<TReturn> {
    constructor(contract: AbstractContract, funcScopes: Array<FunctionInvocationScope>);
    addCall(funcScope: FunctionInvocationScope): this;
    addCalls(funcScopes: Array<FunctionInvocationScope>): this;
}

declare class Contract implements AbstractContract {
    id: AbstractAddress;
    provider: Provider | null;
    interface: Interface;
    account: Account | null;
    functions: InvokeFunctions;
    constructor(id: string | AbstractAddress, abi: JsonAbi | JsonFlatAbi | Interface, accountOrProvider: Account | Provider);
    buildFunction(func: FunctionFragment): (...args: Array<unknown>) => FunctionInvocationScope<unknown[], any>;
    multiCall(calls: Array<FunctionInvocationScope>): MultiCallInvocationScope<any>;
    /**
     * Get the balance for a given assset ID for this contract
     */
    getBalance(assetId: BytesLike): Promise<_fuel_ts_math.BN>;
}

type ScriptResult = {
    code: BN;
    gasUsed: BN;
    receipts: TransactionResultReceipt[];
    scriptResultReceipt: TransactionResultScriptResultReceipt;
    returnReceipt: TransactionResultReturnReceipt | TransactionResultReturnDataReceipt | TransactionResultRevertReceipt;
    callResult: CallResult;
};
declare class ScriptRequest<TData = void, TResult = void> {
    bytes: Uint8Array;
    scriptDataEncoder: (data: TData) => Uint8Array;
    scriptResultDecoder: (scriptResult: ScriptResult) => TResult;
    constructor(bytes: BytesLike, scriptDataEncoder: (data: TData) => Uint8Array, scriptResultDecoder: (scriptResult: ScriptResult) => TResult);
    getScriptDataOffset(): number;
    /**
     * Returns the memory offset for the contract call argument
     * Used for struct inputs
     */
    getArgOffset(): number;
    /**
     * Encodes the data for a script call
     */
    encodeScriptData(data: TData): Uint8Array;
    /**
     * Decodes the result of a script call
     */
    decodeCallResult(callResult: CallResult, logs?: Array<any>): TResult;
}

export { CallConfig, CallOptions, CallParams, Contract, ContractCall, FunctionInvocationResult, FunctionInvocationScope, InvocationResult, InvocationScopeLike, InvokeFunction, InvokeFunctions, MultiCallInvocationScope, ScriptRequest, ScriptResultDecoderError, TransactionCostOptions, TxParams, assert, getDocs };
