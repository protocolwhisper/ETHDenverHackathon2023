import{arrayify as y,hexlify as i}from"@ethersproject/bytes";import{Logger as x}from"@ethersproject/logger";import{AbstractContract as w,AbstractAccount as S}from"@fuel-ts/interfaces";import{randomBytes as E}from"@fuel-ts/keystore";import{versions as L}from"@fuel-ts/versions";import{bech32m as o}from"bech32";var P=new x(L.FUELS),n="fuel";function c(r){return o.decode(r)}function d(r){return o.encode(n,o.toWords(y(i(r))))}function s(r){return typeof r=="string"&&r.indexOf(n+1)===0&&c(r).prefix===n}function A(r){return(r.length===66||r.length===64)&&/(0x)?[0-9a-f]{64}$/i.test(r)}function u(r){return(r.length===130||r.length===128)&&/(0x)?[0-9a-f]{128}$/i.test(r)}function f(r){return new Uint8Array(o.fromWords(c(r).words))}function p(r){return s(r)||P.throwArgumentError("Invalid Bech32 Address","address",r),i(f(r))}function g(r){let{words:h}=c(r);return o.encode(n,h)}var H=r=>r instanceof S?r.address:r instanceof w?r.id:r,a=()=>i(E(32));import{Logger as U}from"@ethersproject/logger";import{sha256 as F}from"@ethersproject/sha2";import{AbstractAddress as I}from"@fuel-ts/interfaces";import{versions as v}from"@fuel-ts/versions";var b=new U(v.FUELS),e=class extends I{constructor(t){super();b.checkNew(new.target,e),this.bech32Address=g(t),s(this.bech32Address)||b.throwArgumentError("Invalid Bech32 Address","address",t)}toAddress(){return this.bech32Address}toB256(){return p(this.bech32Address)}toBytes(){return f(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(t){return this.bech32Address===t.bech32Address}static fromPublicKey(t){let l=F(t);return new e(d(l))}static fromB256(t){return new e(d(t))}static fromRandom(){return this.fromB256(a())}static fromString(t){return s(t)?new e(t):this.fromB256(t)}static fromAddressOrString(t){return typeof t=="string"?this.fromString(t):t}static fromDynamicInput(t){if(typeof t!="string"&&"toB256"in t)return e.fromB256(t.toB256());if(u(t))return e.fromPublicKey(t);if(s(t))return new e(t);if(A(t))return e.fromB256(t);throw new Error("Unknown address format: only Bech32, B256, or Public Key (512) supported")}};export{e as Address,n as FUEL_BECH32_HRP_PREFIX,H as addressify,c as fromBech32,f as getBytesFromBech32,a as getRandomB256,A as isB256,s as isBech32,u as isPublicKey,g as normalizeBech32,p as toB256,d as toBech32};
//# sourceMappingURL=index.mjs.map