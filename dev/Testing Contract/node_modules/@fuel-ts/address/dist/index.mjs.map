{"version":3,"sources":["../src/utils.ts","../src/address.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { AbstractContract, AbstractAccount } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  AddressLike,\n  ContractIdLike,\n  AbstractAddress,\n} from '@fuel-ts/interfaces';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { versions } from '@fuel-ts/versions';\nimport type { Decoded } from 'bech32';\nimport { bech32m } from 'bech32';\n\nconst logger = new Logger(versions.FUELS);\n\n// Fuel Network HRP (human-readable part) for bech32 encoding\nexport const FUEL_BECH32_HRP_PREFIX = 'fuel';\n\n/**\n * Decodes a Bech32 address string into Decoded\n */\nexport function fromBech32(address: Bech32Address): Decoded {\n  return bech32m.decode(address);\n}\n\n/**\n * Converts a B256 address string into Bech32\n */\nexport function toBech32(address: B256Address): Bech32Address {\n  return bech32m.encode(\n    FUEL_BECH32_HRP_PREFIX,\n    bech32m.toWords(arrayify(hexlify(address)))\n  ) as Bech32Address;\n}\n\n/**\n * Determines if a given string is Bech32 format\n */\nexport function isBech32(address: BytesLike): boolean {\n  return (\n    typeof address === 'string' &&\n    address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 &&\n    fromBech32(address as Bech32Address).prefix === FUEL_BECH32_HRP_PREFIX\n  );\n}\n\n/**\n * Determines if a given string is B256 format\n */\nexport function isB256(address: string): boolean {\n  return (address.length === 66 || address.length === 64) && /(0x)?[0-9a-f]{64}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in Public Key format (512 bits)\n */\nexport function isPublicKey(address: string): boolean {\n  return (address.length === 130 || address.length === 128) && /(0x)?[0-9a-f]{128}$/i.test(address);\n}\n\n/**\n * Takes a Bech32 address and returns the byte data\n */\nexport function getBytesFromBech32(address: Bech32Address): Uint8Array {\n  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));\n}\n\n/**\n * Converts a Bech32 address string into B256\n */\nexport function toB256(address: Bech32Address): B256Address {\n  if (!isBech32(address)) {\n    logger.throwArgumentError('Invalid Bech32 Address', 'address', address);\n  }\n\n  return hexlify(getBytesFromBech32(address));\n}\n\n/**\n * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.\n *\n * The input is validated along the way, which makes this significantly safer than\n * using `address.toLowerCase()`.\n */\nexport function normalizeBech32(address: Bech32Address): Bech32Address {\n  const { words } = fromBech32(address);\n  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words) as Bech32Address;\n}\n\nexport const addressify = (addressLike: AddressLike | ContractIdLike): AbstractAddress => {\n  if (addressLike instanceof AbstractAccount) {\n    return addressLike.address;\n  }\n\n  if (addressLike instanceof AbstractContract) {\n    return addressLike.id;\n  }\n\n  return addressLike;\n};\n\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n","import { Logger } from '@ethersproject/logger';\nimport { sha256 } from '@ethersproject/sha2';\nimport { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Bech32Address, B256Address } from '@fuel-ts/interfaces';\nimport { versions } from '@fuel-ts/versions';\n\nimport {\n  normalizeBech32,\n  isBech32,\n  toB256,\n  getBytesFromBech32,\n  toBech32,\n  getRandomB256,\n  isPublicKey,\n  isB256,\n} from './utils';\n\nconst logger = new Logger(versions.FUELS);\n\nexport default class Address extends AbstractAddress {\n  readonly bech32Address: Bech32Address;\n\n  constructor(address: Bech32Address) {\n    super();\n    logger.checkNew(new.target, Address);\n    this.bech32Address = normalizeBech32(address);\n\n    if (!isBech32(this.bech32Address)) {\n      logger.throwArgumentError('Invalid Bech32 Address', 'address', address);\n    }\n  }\n\n  /**\n   * @returns This address as a Bech32m string\n   */\n  toAddress(): Bech32Address {\n    return this.bech32Address;\n  }\n\n  /**\n   * @returns This address as 256 bit hash string\n   */\n  toB256(): B256Address {\n    return toB256(this.bech32Address);\n  }\n\n  /**\n   * @returns Returns this address as a byte array\n   */\n  toBytes(): Uint8Array {\n    return getBytesFromBech32(this.bech32Address);\n  }\n\n  /**\n   * @returns This address as hexed 256 bit hash string\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * Prints this Address value\n   * @returns a string address in Bech32m Format\n   */\n  toString(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Parses this Address value\n   * @returns a string address in Bech32m Format\n   */\n  toJSON(): string {\n    return this.toString();\n  }\n\n  /**\n   * Returns the value of this Address value\n   * @returns a string address in Bech32m Format\n   */\n  valueOf(): string {\n    return this.toString();\n  }\n\n  /**\n   * Compare this Address value to another for direct equality\n   * @param other - the other address to compare against\n   * @returns true if addresses are equal\n   */\n  equals(other: Address): boolean {\n    return this.bech32Address === other.bech32Address;\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an Address\n   * @param publicKey - the wallets public key\n   * @returns a new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    const b256Address = sha256(publicKey);\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Takes a B256Address and creates an Address\n   * @param b256Address - the b256 hash\n   * @returns a new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Creates a random address within an Address\n   * @returns a new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an Address\n   * @returns a new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return isBech32(address) ? new Address(address as Bech32Address) : this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an address\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | AbstractAddress): AbstractAddress {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n\n  /**\n   * Takes an optional string and returns back an Address\n   *\n   * @param addressId - Can be a string containing Bech32, B256, or Public Key\n   * @throws Error\n   * thrown if the input string is not nilsy and cannot be resolved to a valid address format\n   * @returns a new `Address` instance\n   */\n  static fromDynamicInput(address: string | AbstractAddress): Address {\n    // If address is a object than we assume it's a AbstractAddress\n    // we don't check by instanceof because it's possible to\n    // the host app to have a different reference to this same class type\n    if (typeof address !== 'string' && 'toB256' in address) {\n      return Address.fromB256(address.toB256());\n    }\n    if (isPublicKey(address)) {\n      return Address.fromPublicKey(address);\n    }\n\n    if (isBech32(address)) {\n      return new Address(address as Bech32Address);\n    }\n\n    if (isB256(address)) {\n      return Address.fromB256(address);\n    }\n\n    throw new Error('Unknown address format: only Bech32, B256, or Public Key (512) supported');\n  }\n}\n"],"mappings":"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","names":["arrayify","hexlify","Logger","AbstractContract","AbstractAccount","randomBytes","versions","bech32m","logger","FUEL_BECH32_HRP_PREFIX","fromBech32","address","toBech32","isBech32","isB256","isPublicKey","getBytesFromBech32","toB256","normalizeBech32","words","addressify","addressLike","getRandomB256","Logger","sha256","AbstractAddress","versions","logger","Logger","versions","Address","AbstractAddress","address","normalizeBech32","isBech32","toB256","getBytesFromBech32","other","publicKey","b256Address","sha256","toBech32","getRandomB256","isPublicKey","isB256"]}