import{hexlify as h,arrayify as l}from"@ethersproject/bytes";import{Logger as A}from"@ethersproject/logger";import{AbiCoder as T,Interface as R}from"@fuel-ts/abi-coder";import{Address as g}from"@fuel-ts/address";import{transactionRequestify as b}from"@fuel-ts/providers";import{InputType as k}from"@fuel-ts/transactions";import{versions as L}from"@fuel-ts/versions";import{Account as x}from"@fuel-ts/wallet";import{hexlify as u,arrayify as y}from"@ethersproject/bytes";import{calcRoot as d}from"@fuel-ts/merkle";var c=i=>{let t=[],e=y(i);for(let r=0;r<e.length;r+=8){let n=new Uint8Array(8);n.set(e.slice(r,r+8)),t.push(n)}return d(t.map(r=>u(r)))};var C=new A(L.FUELS),p=class extends x{constructor(t,e,r){let n=g.fromB256(c(t));super(n,r);this.predicateData=Uint8Array.from([]);if(this.bytes=l(t),e){this.interface=new R(e);let a=this.interface.fragments.find(({name:f})=>f==="main");a!==void 0?this.types=a.inputs:C.throwArgumentError('Cannot use ABI without "main" function',"Function fragments",this.interface.fragments)}}populateTransactionPredicateData(t){var r;let e=b(t);return(r=e.inputs)==null||r.forEach(n=>{n.type===k.Coin&&h(n.owner)===this.address.toB256()&&(n.predicate=this.bytes,n.predicateData=this.predicateData)}),e}sendTransaction(t){let e=this.populateTransactionPredicateData(t);return super.sendTransaction(e)}simulateTransaction(t){let e=this.populateTransactionPredicateData(t);return super.simulateTransaction(e)}setData(...t){let r=new T().encode(this.types||[],t);return this.predicateData=r,this}};export{p as Predicate};
//# sourceMappingURL=index.mjs.map