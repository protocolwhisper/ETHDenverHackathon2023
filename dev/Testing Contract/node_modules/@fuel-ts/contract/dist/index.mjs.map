{"version":3,"sources":["../src/contract-factory.ts","../src/util.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport type { JsonAbi } from '@fuel-ts/abi-coder';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { Contract } from '@fuel-ts/program';\nimport type { CreateTransactionRequestLike, Provider } from '@fuel-ts/providers';\nimport { CreateTransactionRequest } from '@fuel-ts/providers';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { MAX_GAS_PER_TX } from '@fuel-ts/transactions';\nimport { versions } from '@fuel-ts/versions';\nimport type { Account } from '@fuel-ts/wallet';\n\nimport { getContractId, getContractStorageRoot, includeHexPrefix } from './util';\n\nconst logger = new Logger(versions.FUELS);\n\ntype DeployContractOptions = {\n  salt?: BytesLike;\n  storageSlots?: StorageSlot[];\n  stateRoot?: BytesLike;\n} & CreateTransactionRequestLike;\n\nexport default class ContractFactory {\n  bytecode: BytesLike;\n  interface: Interface;\n  provider!: Provider | null;\n  account!: Account | null;\n\n  constructor(\n    bytecode: BytesLike,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider | null = null\n  ) {\n    // Force the bytecode to be a byte array\n    this.bytecode = arrayify(bytecode);\n\n    if (abi instanceof Interface) {\n      this.interface = abi;\n    } else {\n      this.interface = new Interface(abi);\n    }\n\n    /**\n      Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` have a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n        - ./contract.ts\n\n      @see Contract\n    */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n  }\n\n  connect(provider: Provider | null) {\n    return new ContractFactory(this.bytecode, this.interface, provider);\n  }\n\n  createTransactionRequest(deployContractOptions?: DeployContractOptions) {\n    const storageSlots = deployContractOptions?.storageSlots\n      ?.map(({ key, value }) => ({\n        key: includeHexPrefix(key),\n        value: includeHexPrefix(value),\n      }))\n      .sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));\n\n    const options = {\n      salt: randomBytes(32),\n      ...deployContractOptions,\n      storageSlots: storageSlots || [],\n    };\n\n    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);\n    const contractId = getContractId(this.bytecode, options.salt, stateRoot);\n    const transactionRequest = new CreateTransactionRequest({\n      gasPrice: 0,\n      gasLimit: MAX_GAS_PER_TX,\n      bytecodeWitnessIndex: 0,\n      witnesses: [this.bytecode],\n      ...options,\n    });\n    transactionRequest.addContractCreatedOutput(contractId, stateRoot);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  async deployContract(deployContractOptions?: DeployContractOptions) {\n    if (!this.account) {\n      return logger.throwArgumentError(\n        'Cannot deploy Contract without account',\n        'account',\n        this.account\n      );\n    }\n\n    const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);\n    await this.account.fund(transactionRequest);\n    const response = await this.account.sendTransaction(transactionRequest);\n    await response.wait();\n\n    return new Contract(contractId, this.interface, this.account);\n  }\n}\n","import type { BytesLike, DataOptions } from '@ethersproject/bytes';\nimport { hexlify, arrayify, concat } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\nimport { calcRoot } from '@fuel-ts/merkle';\nimport SparseMerkleTree from '@fuel-ts/sparsemerkle';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 8;\n  const chunks: Uint8Array[] = [];\n  const bytes = arrayify(bytecode);\n\n  for (let offset = 0; offset < bytes.length; offset += chunkSize) {\n    const chunk = new Uint8Array(chunkSize);\n    chunk.set(bytes.slice(offset, offset + chunkSize));\n    chunks.push(chunk);\n  }\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n\nexport const getContractStorageRoot = (storageSlots: StorageSlot[]): string => {\n  const tree = new SparseMerkleTree();\n\n  storageSlots.forEach(({ key, value }) => tree.update(key, value));\n\n  return tree.root;\n};\n\nexport const getContractId = (\n  bytecode: BytesLike,\n  salt: BytesLike,\n  stateRoot: BytesLike\n): string => {\n  const root = getContractRoot(arrayify(bytecode));\n  const contractId = sha256(concat(['0x4655454C', salt, root, stateRoot]));\n  return contractId;\n};\n\nexport const includeHexPrefix = (value: string, options?: DataOptions) =>\n  hexlify(value, {\n    ...options,\n    allowMissingPrefix: true,\n  });\n"],"mappings":"0FACA,OAAS,YAAAA,MAAgB,uBACzB,OAAS,UAAAC,MAAc,wBACvB,OAAS,aAAAC,MAAiB,qBAE1B,OAAS,eAAAC,MAAmB,oBAC5B,OAAS,YAAAC,MAAgB,mBAEzB,OAAS,4BAAAC,MAAgC,qBAEzC,OAAS,kBAAAC,MAAsB,wBAC/B,OAAS,YAAAC,MAAgB,oBCXzB,IAAAC,EAAA,GAAAC,EAAAD,EAAA,mBAAAE,EAAA,oBAAAC,EAAA,2BAAAC,EAAA,qBAAAC,IACA,OAAS,WAAAC,EAAS,YAAAC,EAAU,UAAAC,MAAc,uBAC1C,OAAS,UAAAC,MAAc,sBACvB,OAAS,YAAAC,MAAgB,kBACzB,OAAOC,MAAsB,wBAGtB,IAAMC,EAAmBC,GAAgC,CAE9D,IAAMC,EAAuB,CAAC,EACxBC,EAAQR,EAASM,CAAQ,EAE/B,QAASG,EAAS,EAAGA,EAASD,EAAM,OAAQC,GAAU,EAAW,CAC/D,IAAMC,EAAQ,IAAI,WAAW,CAAS,EACtCA,EAAM,IAAIF,EAAM,MAAMC,EAAQA,EAAS,CAAS,CAAC,EACjDF,EAAO,KAAKG,CAAK,CACnB,CAEA,OAAOP,EAASI,EAAO,IAAKI,GAAMZ,EAAQY,CAAC,CAAC,CAAC,CAC/C,EAEaC,EAA0BC,GAAwC,CAC7E,IAAMC,EAAO,IAAIV,EAEjB,OAAAS,EAAa,QAAQ,CAAC,CAAE,IAAAE,EAAK,MAAAC,CAAM,IAAMF,EAAK,OAAOC,EAAKC,CAAK,CAAC,EAEzDF,EAAK,IACd,EAEaG,EAAgB,CAC3BX,EACAY,EACAC,IACW,CACX,IAAMC,EAAOf,EAAgBL,EAASM,CAAQ,CAAC,EAE/C,OADmBJ,EAAOD,EAAO,CAAC,aAAciB,EAAME,EAAMD,CAAS,CAAC,CAAC,CAEzE,EAEaE,EAAmB,CAACL,EAAeM,IAC9CvB,EAAQiB,EAAO,CACb,GAAGM,EACH,mBAAoB,EACtB,CAAC,ED3BH,IAAMC,EAAS,IAAIC,EAAOC,EAAS,KAAK,EAQnBC,EAArB,KAAqC,CAMnC,YACEC,EACAC,EACAC,EAA+C,KAC/C,CAEA,KAAK,SAAWC,EAASH,CAAQ,EAE7BC,aAAeG,EACjB,KAAK,UAAYH,EAEjB,KAAK,UAAY,IAAIG,EAAUH,CAAG,EAgBhCC,GAAqB,aAAcA,GACrC,KAAK,SAAWA,EAAkB,SAClC,KAAK,QAAUA,IAEf,KAAK,SAAWA,EAChB,KAAK,QAAU,KAEnB,CAEA,QAAQG,EAA2B,CACjC,OAAO,IAAIN,EAAgB,KAAK,SAAU,KAAK,UAAWM,CAAQ,CACpE,CAEA,yBAAyBC,EAA+C,CAtE1E,IAAAC,EAuEI,IAAMC,GAAeD,EAAAD,GAAA,YAAAA,EAAuB,eAAvB,YAAAC,EACjB,IAAI,CAAC,CAAE,IAAAE,EAAK,MAAAC,CAAM,KAAO,CACzB,IAAKC,EAAiBF,CAAG,EACzB,MAAOE,EAAiBD,CAAK,CAC/B,IACC,KAAK,CAAC,CAAE,IAAKE,CAAK,EAAG,CAAE,IAAKC,CAAK,IAAMD,EAAK,cAAcC,CAAI,GAE3DC,EAAU,CACd,KAAMC,EAAY,EAAE,EACpB,GAAGT,EACH,aAAcE,GAAgB,CAAC,CACjC,EAEMQ,EAAYF,EAAQ,WAAaG,EAAuBH,EAAQ,YAAY,EAC5EI,EAAaC,EAAc,KAAK,SAAUL,EAAQ,KAAME,CAAS,EACjEI,EAAqB,IAAIC,EAAyB,CACtD,SAAU,EACV,SAAUC,EACV,qBAAsB,EACtB,UAAW,CAAC,KAAK,QAAQ,EACzB,GAAGR,CACL,CAAC,EACD,OAAAM,EAAmB,yBAAyBF,EAAYF,CAAS,EAE1D,CACL,WAAAE,EACA,mBAAAE,CACF,CACF,CAEA,MAAM,eAAed,EAA+C,CAClE,GAAI,CAAC,KAAK,QACR,OAAOV,EAAO,mBACZ,yCACA,UACA,KAAK,OACP,EAGF,GAAM,CAAE,WAAAsB,EAAY,mBAAAE,CAAmB,EAAI,KAAK,yBAAyBd,CAAqB,EAC9F,aAAM,KAAK,QAAQ,KAAKc,CAAkB,EAE1C,MADiB,MAAM,KAAK,QAAQ,gBAAgBA,CAAkB,GACvD,KAAK,EAEb,IAAIG,EAASL,EAAY,KAAK,UAAW,KAAK,OAAO,CAC9D,CACF","names":["arrayify","Logger","Interface","randomBytes","Contract","CreateTransactionRequest","MAX_GAS_PER_TX","versions","util_exports","__export","getContractId","getContractRoot","getContractStorageRoot","includeHexPrefix","hexlify","arrayify","concat","sha256","calcRoot","SparseMerkleTree","getContractRoot","bytecode","chunks","bytes","offset","chunk","c","getContractStorageRoot","storageSlots","tree","key","value","getContractId","salt","stateRoot","root","includeHexPrefix","options","logger","Logger","versions","ContractFactory","bytecode","abi","accountOrProvider","arrayify","Interface","provider","deployContractOptions","_a","storageSlots","key","value","includeHexPrefix","keyA","keyB","options","randomBytes","stateRoot","getContractStorageRoot","contractId","getContractId","transactionRequest","CreateTransactionRequest","MAX_GAS_PER_TX","Contract"]}